.. role:: emoji-size

.. meta::
   :description: کتاب آنلاین و آزاد آموزش زبان برنامه‌نویسی پایتون به فارسی - درس چهاردهم تابع
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, تابع, Decorator, پایتون, lambda, Generator, Coroutine


درس ۱۴: تابع - بخش سوم
========================

این درس بخش پایانی از بررسی تابع در پایتون می‌باشد و موضوعات باقی‌مانده از مبحث تابع پایتون در این درس بیان می‌شود. 






:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----




تابع بازگشتی
------------

از درس نهم با دستورات کنترلی ``for`` و ``while`` آشنا شده‌ایم، این دستورات تنها ابزار ما برای تکرار قسمتی از کد بودند. اکنون با پیاده‌سازی شیوه‌ای جدید در تکرار آشنا می‌شویم.

به بیانی ساده، **تابع بازگشتی** (Recursive function) به تابعی گفته می‌شود که خود را از داخل بدنه خود فراخوانی می‌کند. پیاده‌سازی تابع به صورت بازگشتی شیوه‌ای است که از آن برای حل برخی مسائل بهره گرفته می‌شود و باید بدانیم که توابع بازگشتی، یک سینتکس یا دستور خاص در زبان پایتون نیست بلکه یک شیوه حل مسئله می‌باشد که با استفاده از تابع در زبان برنامه‌نویسی پایتون (همچون بسیاری از زبان‌های دیگر) قابل پیاده‌سازی است. 

برای مثال در نمونه کد پایین مقدار فاکتوریل (`Factorial <https://en.wikipedia.org/wiki/Factorial>`_) عدد پنج را به شیوه بازگشتی محاسبه می‌کنیم::


  >>> def factorial(n):
  ...     if n <= 1:
  ...         return 1 
  ...     else:
  ...         return n * factorial(n - 1)
  ... 
  >>> 
  >>> factorial(5)
  120
  >>>

عموما می‌توان مسئله‌هایی که از **توالی** انجام یک **کار یکسان** قابل حل هستند را به صورت بازگشتی پیاده‌سازی کرد. مراحل اجرای نمونه کد بالا به صورت زیر است:

.. image:: /_static/l14-factorial-relation.png
    :align: center

:: 

  factorial(5)
  |--> 5 * factorial(4)
           |--> 4 * factorial(3)
                    |--> 3 * factorial(2)
                             |--> 2 * factorial(1)
                                      |--> 1

  120 = 5 * (4 * (3 * (2 * 1)))

**توضیح:** هنگامی ``factorial(5)`` فراخوانی می‌شود (``n == 5``)، شرط ``1 => n`` رد و بخش ``else`` اجرا می‌شود. در این مرحله نمونه دیگری از تابع با آرگومان ``4`` فراخوانی‌ می‌شود و اجرای ``factorial(5)`` منتظر پایان اجرای ``factorial(4)`` و دریافت نتیجه آن می‌ماند. به همین ترتیب چندین نمونه از یک تابع اجرا می‌شوند که منتظر دریافت نتیجه از نمونه بعد از خود هستند. در نهایت شرط ``1 => n`` برقرار می‌شود و نمونه ``factorial(1)`` نتیجه خود را به ``factorial(2)`` برمی‌گرداند. به همین ترتیب نتایج بازگشت داده می‌شوند تا به نمونه نخست اجرا شده یعنی ``factorial(5)`` برسد و اجرای مورد نظر کاربر به پایان برسد.

مدیریت توالی تابع (شیوه بازگشتی) در حافظه با استفاده از ساختمان داده پشته (Stack) [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Stack_(abstract_data_type)>`__] انجام می‌شود.

هر تابع بازگشتی شامل دو بخش مهم است:

* یک عبارت حاوی فراخوانی خود تابع
* یک شرط برای انتخاب بین فراخوانی مجدد و پایان

**پیاده‌سازی شیوه بازگشتی شاید به نظر هیجان‌انگیز باشد اما نباید فراموش کرد که میزان حافظه (Memory) زیادی مصرف می‌کند، اجرای آن زمان‌بر خواهد بود، درک جریان اجرای آن اغلب سخت است و اشکال‌زدایی (debug) آن ساده نخواهد بود!**

تنظیم عمق بازگشتی
~~~~~~~~~~~~~~~~~~~~

در زبان برنامه‌نویسی پایتون در عمق پیاده‌سازی توابع بازگشتی (تعداد نمونه‌های فراخوانی شده از تابع و موجود در پشته) یک محدودیت قابل تنظیم وجود دارد. تابع ``()getrecursionlimit`` از ماژول ``sys`` این مقدار را برمی‌گرداند [`اسناد پایتون <https://docs.python.org/3/library/sys.html#sys.getrecursionlimit>`__]. این مقدار به صورت پیش‌فرض برابر با ``1000`` 	می‌باشد که با استفاده از تابع ``(limit)setrecursionlimit`` از ماژول ``sys`` می‌توان آن را تغییر داد [`اسناد پایتون <https://docs.python.org/3/library/sys.html#sys.setrecursionlimit>`__]::

  >>> import sys

  >>> sys.getrecursionlimit()
  1000

  >>> sys.setrecursionlimit(50)

  >>> sys.getrecursionlimit()
  50

با رد شدن از محدودیت عمق توابع بازگشتی یک استثنا ``RecursionError`` گزارش خواهد شد::

  
  >>> factorial(9)
  362880

  >>> sys.setrecursionlimit(10)

  >>> factorial(9)
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "<stdin>", line 5, in factorial
    File "<stdin>", line 5, in factorial
    File "<stdin>", line 5, in factorial
    [Previous line repeated 5 more times]
    File "<stdin>", line 2, in factorial
  RecursionError: maximum recursion depth exceeded in comparison

.. tip::
    علاوه بر این محدودیت، یک محدودیت جدی‌تر دیگری نیز وجود دارد و آن هم میزان فضایی است که توسط سیستم عامل برای پشته در نظر گرفته شده است. با رد شدن از این مقدار فضا، برنامه با خطای زمان اجرا مواجه می‌گردد (``RuntimeError``).









|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <http://www.coderz.ir/python-tutorial-function-decorator-generator-yield-coroutine-lambda/>`_



