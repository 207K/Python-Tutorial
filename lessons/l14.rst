.. role:: emoji-size

.. meta::
   :description: کتاب آنلاین و آزاد آموزش زبان برنامه‌نویسی پایتون به فارسی - درس چهاردهم تابع
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, تابع, Decorator, پایتون, lambda, Generator, Coroutine


درس ۱۴: تابع - بخش سوم
========================

این درس بخش پایانی از بررسی تابع در پایتون می‌باشد و موضوعات باقی‌مانده از مبحث تابع پایتون در این درس بیان می‌شود. 






:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----




تابع بازگشتی
------------

از درس نهم با دستورات کنترلی ``for`` و ``while`` آشنا شده‌ایم، این دستورات تنها ابزار ما برای تکرار قسمتی از کد بودند. اکنون با پیاده‌سازی شیوه‌ای جدید در تکرار آشنا می‌شویم.

به بیانی ساده، **تابع بازگشتی** (Recursive function) به تابعی گفته می‌شود که خود را از داخل بدنه خود فراخوانی می‌کند. پیاده‌سازی تابع به صورت بازگشتی شیوه‌ای است که از آن برای حل برخی مسائل بهره گرفته می‌شود و باید بدانیم که توابع بازگشتی، یک سینتکس یا دستور خاص در زبان پایتون نیست بلکه یک شیوه حل مسئله می‌باشد که با استفاده از تابع در زبان برنامه‌نویسی پایتون (همچون بسیاری از زبان‌های دیگر) قابل پیاده‌سازی است. 

برای مثال در نمونه کد پایین مقدار فاکتوریل (`Factorial <https://en.wikipedia.org/wiki/Factorial>`_) عدد پنج را به شیوه بازگشتی محاسبه می‌کنیم::


  >>> def factorial(n):
  ...     if n <= 1:
  ...         return 1 
  ...     else:
  ...         return n * factorial(n - 1)
  ... 
  >>> 
  >>> factorial(5)
  120
  >>>

عموما می‌توان مسئله‌هایی که از **توالی** انجام یک **کار یکسان** قابل حل هستند را به صورت بازگشتی پیاده‌سازی کرد. مراحل اجرای نمونه کد بالا به صورت زیر است:

.. image:: /_static/l14-factorial-relation.png
    :align: center

:: 

  factorial(5)
  |--> 5 * factorial(4)
           |--> 4 * factorial(3)
                    |--> 3 * factorial(2)
                             |--> 2 * factorial(1)
                                      |--> 1

  120 = 5 * (4 * (3 * (2 * 1)))

**توضیح:** هنگامی ``factorial(5)`` فراخوانی می‌شود (``n == 5``)، شرط ``1 => n`` رد و بخش ``else`` اجرا می‌شود. در این مرحله نمونه دیگری از تابع با آرگومان ``4`` فراخوانی‌ می‌شود و اجرای ``factorial(5)`` منتظر پایان اجرای ``factorial(4)`` و دریافت نتیجه آن می‌ماند. به همین ترتیب چندین نمونه از یک تابع اجرا می‌شوند که منتظر دریافت نتیجه از نمونه بعد از خود هستند. در نهایت شرط ``1 => n`` برقرار می‌شود و نمونه ``factorial(1)`` نتیجه خود را به ``factorial(2)`` برمی‌گرداند. به همین ترتیب نتایج بازگشت داده می‌شوند تا به نمونه نخست اجرا شده یعنی ``factorial(5)`` برسد و اجرای مورد نظر کاربر به پایان برسد.

مدیریت توالی تابع (شیوه بازگشتی) در حافظه با استفاده از ساختمان داده پشته (Stack) [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Stack_(abstract_data_type)>`__] انجام می‌شود.

هر تابع بازگشتی شامل دو بخش مهم است:

* یک عبارت حاوی فراخوانی خود تابع
* یک شرط برای انتخاب بین فراخوانی مجدد و پایان

.. note::
    پیاده‌سازی شیوه بازگشتی شاید به نظر هیجان‌انگیز باشد اما نباید فراموش کرد که میزان حافظه (Memory) زیادی مصرف می‌کند، اجرای آن زمان‌بر خواهد بود، درک جریان اجرای آن اغلب سخت است و اشکال‌زدایی (debug) آن ساده نخواهد بود!


استفاده از decorator
~~~~~~~~~~~~~~~~~~~~~

هنگام استفاده از decorator بر روی توابع بازگشتی باید به این نکته توجه داشته باشید که این decorator بر روی تمامی نمونه‌های فراخوانی شده از تابع اعمال خواهد شد و اینکه تنها یک نمونه از decorator ایجاد می‌شود و تمام نمونه‌‌های تابع به همان یک نمونه ارسال می‌شوند::

  >>> def logger(func):
  ...     print('Decorator is created!')
  ...     def func_wrapper(number):
  ...         print(f'New factorial call with parameter: {number}')
  ...         result = func(number)
  ...         print (f'factorial({number}) ==> {result}')
  ...         return result
  ...     return func_wrapper
  ... 
  >>> @logger
  ... def factorial(n):
  ...     if n <= 1:
  ...         return 1
  ...     else:
  ...         return n * factorial(n - 1)
  ... 
  >>> 
  >>> factorial(5)
  Decorator is created!
  New factorial call with parameter: 5
  New factorial call with parameter: 4
  New factorial call with parameter: 3
  New factorial call with parameter: 2
  New factorial call with parameter: 1
  factorial(1) ==> 1
  factorial(2) ==> 2
  factorial(3) ==> 6
  factorial(4) ==> 24
  factorial(5) ==> 120
  120
  >>> 

*به خروجی نمونه کد بالا حتما توجه نمایید!.*

تنظیم عمق بازگشتی
~~~~~~~~~~~~~~~~~~~~

در زبان برنامه‌نویسی پایتون در عمق پیاده‌سازی توابع بازگشتی (تعداد نمونه‌های فراخوانی شده از تابع و موجود در پشته) یک محدودیت قابل تنظیم وجود دارد. تابع ``()getrecursionlimit`` از ماژول ``sys`` این مقدار را برمی‌گرداند [`اسناد پایتون <https://docs.python.org/3/library/sys.html#sys.getrecursionlimit>`__]. این مقدار به صورت پیش‌فرض برابر با ``1000`` 	می‌باشد که با استفاده از تابع ``(limit)setrecursionlimit`` از ماژول ``sys`` می‌توان آن را تغییر داد [`اسناد پایتون <https://docs.python.org/3/library/sys.html#sys.setrecursionlimit>`__]::

  >>> import sys

  >>> sys.getrecursionlimit()
  1000

  >>> sys.setrecursionlimit(50)

  >>> sys.getrecursionlimit()
  50

با رد شدن از محدودیت عمق توابع بازگشتی یک استثنا ``RecursionError`` گزارش خواهد شد::

  
  >>> factorial(9)
  362880

  >>> sys.setrecursionlimit(10)

  >>> factorial(9)
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "<stdin>", line 5, in factorial
    File "<stdin>", line 5, in factorial
    File "<stdin>", line 5, in factorial
    [Previous line repeated 5 more times]
    File "<stdin>", line 2, in factorial
  RecursionError: maximum recursion depth exceeded in comparison

.. tip::
    علاوه بر این محدودیت، یک محدودیت جدی‌تر دیگری نیز وجود دارد و آن هم میزان فضایی است که توسط سیستم عامل برای پشته در نظر گرفته شده است. با رد شدن از این مقدار فضا، برنامه با خطای زمان اجرا مواجه می‌گردد (``RuntimeError``).

تابع Generator بازگشتی
~~~~~~~~~~~~~~~~~~~~~~

در پیاده‌سازی توابع Generator و Coroutine نیز می‌توان شیوه بازگشتی را در نظر گرفت، در این صورت ممکن است نتایج کمی برخلاف انتظار شما باشد. نمونه کد زیر یک شی لیست تو در تو را دریافت و تک تک اعضای درون هر لیست را چاپ می‌کند::

  >>> def flatten(lists):
  ...     for sub in lists:
  ...         if isinstance(sub,list):
  ...             flatten(sub)
  ...         else:
  ...             print(sub)
  ... 
  >>> items = [[1,2,3],[4,5,[5,6]],[7,8,9]]
  >>> flatten(items)
  1
  2
  3
  4
  5
  5
  6
  7
  8
  9
  >>> 

اکنون برای تبدیل تابع ``flatten`` به یک  Generator کافی است به جای ``print`` از ``yield`` استفاده کنیم::

  >>> def genflatten(lists):
  ...     for sub in lists:
  ...         if isinstance(sub,list):
  ...             genflatten(sub)
  ...         else:
  ...             yield sub
  ... 
  >>> items = [[1,2,3],[4,5,[5,6]],[7,8,9]]

  >>> genflatten(items)
  <generator object genflatten at 0x7eff06d40150>

  >>> list(genflatten(items))
  []


اتفاقی نیفتاد! و خروجی یک لیست خالی است. از درس پیش به خاطر داریم، فراخوانی تابع ``genflatten`` (که در واقع یک تابع Generator است) تنها باعث ایجاد یک شی Generator می‌شود و می‌بایست در نقطه‌ای که تابع خودش را فراخوانی می‌کند نیز مقدمات پردازش خروجی یک شی Generator را فراهم کنیم. اکنون با اصلاح کد بالا::

  >>> def genflatten(lists):
  ...     for sub in lists:
  ...         if isinstance(sub,list):
  ...             for item in genflatten(sub):
  ...                 yield item
  ...         else:
  ...             yield sub
  ... 
  >>> items = [[1,2,3],[4,5,[5,6]],[7,8,9]]

  >>> genflatten(items)
  <generator object genflatten at 0x7f6cee349258>

  >>> list(genflatten(items))
  [1, 2, 3, 4, 5, 5, 6, 7, 8, 9]


Memoization
~~~~~~~~~~~~~

**Memoization** یا یادآوری، یک تکنیک برای نگهداری از نتایج به دست آمده به منظور جلوگیری از تکرار محاسبات است [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Memoization>`__]. این تکنیک را می‌توان در زبان برنامه‌نویسی پایتون با استفاده از **decorator** پیاده‌سازی کرد.

برای توضیح این بخش اجازه دهید یک مثال بازگشتی دیگر را بررسی کنیم. محاسبه مقدار فیبوناچی [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Fibonacci_number>`__] یک عدد مشخص:

.. image:: /_static/l14-fibonacci-relation.png
    :align: center

::

  >>> def fibonacci(n):
  ...     if n <= 1:
  ...         return n
  ...     else:
  ...         return fibonacci(n-1) + fibonacci(n-2)
  ... 
  >>> for number in range(10):
  ...    print(fibonacci(number))
  ... 
  0
  1
  1
  2
  3
  5
  8
  13
  21
  34

  
در این مثال ما از عدد ``9`` جلوتر نرفتیم چرا که محاسبه برای اعداد بزرگتری به مانند ``50`` واقعا زمان‌بر خواهد بود و این فرصتی است تا ما کارایی تکنیک Memoization را محک بزنیم. اکنون تابع بازگشتی فیبوناچی خود را با استفاده از تکنیک Memoization و یک Decorator بهینه‌سازی می‌کنیم::

  >>> def memoize_fibonacci(func):
  ...     memory = {} 
  ...     def func_wrapper(number): 
  ...         if number not in memory: 
  ...             memory[number] = func(number)
  ...         return memory[number]
  ...     return func_wrapper
  ... 
  >>> @memoize_fibonacci
  ... def fibonacci(n):
  ...     if n <= 1:
  ...         return n
  ...     else:
  ...         return fibonacci(n-1) + fibonacci(n-2)
  ... 
  >>> 

حالا مقدار ``50`` که هیچ، مقدار فیبوناچی برای عدد ``500`` را محاسبه کنید (``(500)fibonacci``). تفاوت در زمان اجرا را خودتان متوجه خواهید شد!


به کمک Decorator در این مثال (``memoize_fibonacci``) نتایج حاصل از فراخوانی هر نمونه تابع در جایی ذخیره می‌شود (شی دیکشنری ``memory``) و پیش از فراخوانی مجدد یک نمونه جدید از تابع بررسی می‌شود که آیا قبلا این مقدار محاسبه شده است یا خیر. در صورت وجود جواب از تکرار فراخوانی تابع صرف نظر و مقدار از پیش موجود به عنوان نتیجه برگردانده می‌شود. بنابراین بدیهی است که با جلوگیری از ایجاد نمونه توابع جدید و محاسبات تکراری، سرعت اجرا افزایش یابد.



















|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <http://www.coderz.ir/python-tutorial-function-decorator-generator-yield-coroutine-lambda/>`_



