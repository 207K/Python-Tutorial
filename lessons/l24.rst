.. role:: emoji-size

.. meta::
   :description: کتاب آموزش زبان برنامه نویسی پایتون به فارسی، مدیریت خطا در پایتون، raise Exception در پایتون، Warning در پایتون، Assertion پایتون
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, کتابخانه, پایتون, Exception در پایتون


درس ۲۴: مدیریت خطا در پایتون: Warning ،raise Exception و Assertion
===================================================================================================

.. figure:: /_static/pages/24-python-raise-exception-warning-assertion.jpg
    :align: center
    :alt: مدیریت خطا در پایتون:Warning ،raise Exception و Assertion

    Photo by `Sandy Manoa <https://unsplash.com/photos/DnuC3-ZNBPQ>`__
  
  



توجه داشته باشید، هم اکنون پشتیبانی نسخه 2x پایتون به پایان رسیده است. بنابراین	به منظور جلوگیری از پیچیدگی‌های غیر ضروری، تمام مطالب این درس بر مبنای پایتون 3x ارائه می‌شود.



:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----


دستور ``raise``
~~~~~~~~~~~~~~~~~~~~~~~~~~~

از درس پیش با Exception آشنا شدیم و مشاهده کردیم در زمان اجرای برنامه پایتونی تمامی خطاها در قالب یک Exception اعلام می‌گردند. اما در برنامه‌نویسی زمان‌های بسیاری خواهد بود که برنامه‌نویس می‌بایست خود اقدام به بروز Exception نماید. یک ماژول در هنگام انجام کار مشخصی ممکن است با وضعیت‌های مختلفی روبرو گردد که می‌بایست این وضعیت‌ها را به ماژول سطح بالاتر خود اعلام کند تا در نهایت نتیجه و توضیح مناسب برای کاربر فراهم گردد. برای مثال در پیاده‌سازی API ماژولی که انجام خدمت را به عهده دارد، هنگامی که به خطا یا وضعیتی  خاص برخورد می‌کند، می‌تواند این وضعیت را در قالب بروز یک Exception اعلام می‌کند و ماژولی که وظیفه تولید پاسخ یا Response را برعهده دارد، بر اساس نوع Exception رخ داده می‌تواند یک Response مناسب تولید نماید.

در زبان برنامه‌نویسی پایتون از دستور ``raise`` [`اسناد پایتون <https://docs.python.org/3/reference/simple_stmts.html#raise>`__] برای بروز یک Exception استفاده می‌گردد::

    raise exception_object

به نمونه کد زیر توجه نمایید:

.. code-block:: python
    :linenos:
    
    def self_sum_int(a):
        if not isinstance(a, int):
            raise TypeError()
        
        return a + a

    res = self_sum_int('C')
    print(res)


::

    Traceback (most recent call last):
      File "sample.py", line 7, in <module>
        res = self_sum_int('C')
      File "sample.py", line 3, in self_sum_int
        raise TypeError()
    TypeError

در نمونه کد بالا ما یک شی از کلاس ``TypeError`` ایجاد و آن را raise کردیم (سطر ۳). همانطور که مشاهده می‌کنید، شرح Exception در Traceback (سطر پایانی) با آن چیزی که در درس پیش شاهد آن بودیم، متفاوت است و همچنین علت بروز Exception نیز raise شدن آن اعلام شده است. 

می‌توان در هنگام نمونه‌سازی از کلاس Exception مورد نظر، یک متن دلخواه (یک شی از نوع ``str``) به عنوان شرح Exception در زمان نمونه‌سازی به صورت آرگومان ارسال کنیم:


.. code-block:: python
    :linenos:
    
    def self_sum_int(a):
        if not isinstance(a, int):
            raise TypeError(f"The input must be 'int' type, {a!r} is {type(a)}")
        
        return a + a

    res = self_sum_int('C')
    print(res)


::

    Traceback (most recent call last):
      File "sample.py", line 7, in <module>
        res = self_sum_int('C')
      File "sample.py", line 3, in self_sum_int
        raise TypeError(f'The input must be of the integer type, {a} is {type(a)}')
    TypeError: The input must be 'int' type, 'C' is <class 'str'>


طی درس پیش مشاهده کردیم، چنانچه در زمان handle کردن یک Exception، یک Exception دیگر رخ دهد؛ در نتیجه Traceback نهایی نیز شامل یک Traceback به ازای هر Exception خواهد بود. این امکان نیز توسط دستور ``raise`` برای برنامه‌نویس فراهم می‌باشد. می‌توان با استفاده از دستور ``from`` در کنار  ``raise``،  دو Exception - که از نظر منطقی به یکدیگر وابسته هستند - را به یکدیگر متصل و سپس raise کرد::

   raise exception_object from other_exception_object

به نمونه کد ساده زیر و خروجی آن توجه نمایید:

.. code-block:: python
    :linenos:
    
    def sum_int(a, b):
        try:
            return a + b
        except Exception as exception:
            raise RuntimeError("Something bad happened") from exception

    res = sum_int(3, 'C')
    print(res)

::

    Traceback (most recent call last):
      File "sample.py", line 3, in sum_int
        return a + b
    TypeError: unsupported operand type(s) for +: 'int' and 'str'

    The above exception was the direct cause of the following exception:

    Traceback (most recent call last):
      File "sample.py", line 7, in <module>
        res = sum_int(3, 'C')
      File "sample.py", line 5, in sum_int
        raise RuntimeError("Something bad happened") from exception
    RuntimeError: Something bad happened

به عنوان یک نمونه کاربرد، از این روش می‌توان برای ایجاد یک Wrapper برای چندین Exception بهره برد. در این حالت کد سطح بالاتر تنها نیاز است یک نوع Exception را handle نماید:

.. code-block:: python
    :linenos:
    
    def sum_int(a, b):
        try:
            return a + b
        except TypeError as type_err:
            raise RuntimeError(f'Something bad happened \n    => {str(type_err)}') from type_err



    try:
        res = sum_int(3, 'C')
        print(res)
    
    except RuntimeError as runtime_err:
        print(f'{runtime_err.__class__.__name__}: {str(runtime_err)}')

::

    RuntimeError: Something bad happened 
        => unsupported operand type(s) for +: 'int' and 'str'

ایجاد Exception
~~~~~~~~~~~~~~~~~~~~~~~~~~~

در زبان برنامه‌نویسی پایتون با ایجاد یک کلاس و ارث‌بری از ``Exception`` یا یکی از subclassهای آن می‌توان یک Exception جدید ایجاد نمود:

.. code-block:: python
    :linenos:
    
    class NegativeNumberError(Exception):
        """Raised when the input value is negative number"""
        pass


    def plus(num):
        if num < 0:
            raise NegativeNumberError(f'{num} is a negative number!')
            
        return num + num


    try:
        print(plus(10))
        print('*' * 30)
        print(plus(-5))
    
    except NegativeNumberError as err:
        print(str(err))
    
    except:
        print('Something bad happened!')
        
::

   20
   ******************************
   -5 is a negative number!

بدیهی است که می‌توان کلاس‌های Exception خود را مطابق با میل خود پیاده‌سازی نمود:

.. code-block:: python
    :linenos:
    
    class NegativeNumberError(Exception):
        """Raised when the input value is negative number"""
    
        def __init__(self, number, message="Number must be positive"):
            self.number = number
            self.message = message
            super().__init__(self.message)

        def __str__(self):
            return f'ERROR[{self.number}] -> {self.message}'


    def plus(num):
        if num < 0:
            raise NegativeNumberError(num)
            
        return num + num


    try:
        print(plus(10))
        print('*' * 30)
        print(plus(-5))
    
    except NegativeNumberError as err:
        print(str(err))
    
    except:
        print('Something bad happened!')
        
::

   20
   ******************************
   ERROR[-5] -> Number must be positive


.. note::
  در  زبان‌برنامه‌نویسی پایتون پیشنهاد می‌شود که اگر هدف از ایجاد Exception نمایش یک خطا باشد، در انتهای نام کلاس از واژه Error استفاده گردد.


Context Manager و ``with``
~~~~~~~~~~~~~~~~~~~~~~~~~~~


ماژول warnings
~~~~~~~~~~~~~~~~~~~~~~~~~~~



دستور ``assert``
~~~~~~~~~~~~~~~~~~~~~~~~~~~



|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <https://www.coderz.ir/python-tutorial-raise-exception-warnings-assertion>`_



