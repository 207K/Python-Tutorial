.. role:: emoji-size

.. meta::
   :description: کتاب آموزش زبان برنامه نویسی پایتون به فارسی، آموزش شی گرایی در پایتون، معرفی رابطه های وراثت (Inheritance) و انجمن (Association) در پایان، OOP در پایتون
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, تابع, کتابخانه, پایتون, شی گرایی در پایتون


درس ۱۸: شی گرایی (OOP) در پایتون: وراثت (Inheritance) و انجمن (Association)
========================================================================================================



این درس در ادامه درس پیش می‌باشد و به بررسی رابطه بین کلاس‌ها و اشیا می‌پردازد. در درس پنجم مقدمه‌ای از این روابط صحبت شده است و این درس  به صورت کامل دو رابطه **IS-A** یا Inheritance و **HAS-A** یا Association در مفهموم شی گرایی و چگونگی پیاده‌سازی آن‌ها در زبان برنامه‌نویسی پایتون را شرح می‌دهد.

توجه داشته باشید، هم اکنون پشتیبانی نسخه 2x پایتون به پایان رسیده است. بنابراین	همانند درس پیش و به منظور جلوگیری از پیچیدگی‌های غیر ضروری، تمام مطالب این درس بر مبنای پایتون 3x ارائه می‌شود.



:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----


وراثت (Inheritance)
----------------------------------

وراثت به معنی امکانی است که یک کلاس بتواند صفات و رفتارهای یک کلاس دیگر را نیز به همراه خود داشته باشد. پیاده‌سازی وراثت در پایتون حداقل به دو کلاس نیاز دارد:

* **base class** یا **superclass**: کلاس اصلی یا کلاسی می‌خواهیم کلاس یا کلاس‌های دیگری آن را به ارث ببرند و صفات و رفتارهای آن به دیگر کلاس(ها) سرایت پیدا کند.
* **derived class** یا **subclass**: کلاس یا کلاس‌هایی که از superclass ارث‌بری خواهند داشت.

.. image:: /_static/l18-python-oop-inheritance.jpg
    :align: center

تصویر بالا یک نمونه ساده از ساختار وراثت را نمایش می‌دهد. در برنامه ما قرار است یک کلاس گنجشک (Sparrow) و سگ (Dog) ایجاد گردد، از آنجا که برخی از رفتارهای این دو کلاس یکسان است مانند راه رفتن (Walk) یا نفس کشیدن (Breathe)، یک superclass کلاس برای آن‌ها با نام Animal ایجاد می‌کنیم که شامل صفات و رفتارهای مشترک دو کلاس نام برده باشد - پیاده‌سازی پایتونی تصویر بالا به صورت نمونه کد زیر خواهد بود:

.. code-block:: python
    :linenos:

    class Animal:

        def walk(self):
          print(f'{self.__class__.__name__}: wlking...')
    
        def breathe(self):
          print(f'{self.__class__.__name__}: breathing...')
    
    
    class Sparrow(Animal):
    
        def fly(self):
          print(f'{self.__class__.__name__}: flying...')
    
    
    class Dog(Animal):
    
        def run(self):
          print(f'{self.__class__.__name__}: running...')
    
    
    sparrow = Sparrow()
    dog = Dog()
    
    sparrow.walk()
    sparrow.breathe()
    sparrow.fly()

    print('-' * 30)

    dog.walk()
    dog.breathe()
    dog.run()

::

    Sparrow: wlking...
    Sparrow: breathing...
    Sparrow: flying...
    ------------------------------
    Dog: wlking...
    Dog: breathing...
    Dog: running...

.. tip:: 

  همانطور که از نمونه کد بالا مشاهده می‌شود، زمانی که یک شی subclass، متد superclass خود را فراخوانی می‌کند، مقدار ``self`` در متد superclass برابر با شی فراخوانی کننده متد یعنی همان subclass خواهد بود. 

به صورت پیش‌فرض هر شی پایتون حاوی  Attributeها و متدهایی است که فهرست آن‌ها با استفاده از تابع ``dir`` [`اسناد پایتون <https://docs.python.org/3/library/functions.html#dir>`__] قابل مشاهده خواهد بود. با این توضیح صفت ``__self.__class``  حاوی کلاس شی می‌باشد و ``__self.__class__.__name`` نیز نام کلاس شی را در بر دارد - *این موضوع در درس‌های پیش نیز مطرح شده بود*::

    >>> class Sample:
    ...     def imethod(self):
    ...         print(dir(self))
    ...         print()
    ...         print(self.__class__)
    ... 
    >>> 
    >>> sample = Sample()
    >>> sample.imethod()
    ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'imethod']

    <class '__main__.Sample'>
    >>> 

با این حال، برخی اشیا پایتون حاوی  Attributeهایی هستند که ممکن است توسط تابع ``dir``  نمایش داده نشود. از این  Attributeها به عنوان Special Attributes یاد می‌شود [`اسناد پایتون <https://docs.python.org/3/library/stdtypes.html#special-attributes>`__]. برای مثال صفت ``__definition.__name`` بسته به نوع definition، حاوی نام کلاس، تابع، متد یا غیره می‌باشد.

همان‌طور که بیان شد subclass‌ها به Attributeهای superclass کلاس خود نیز دسترسی دارند، به نمونه کدی دیگر نیز توجه نمایید:

.. code-block:: python
    :linenos:

    class SuperClass:
        super_class_attr = {'one':1, 'two':2}
    
        def __init__(self, param_1):
            self.super_instance_attr = param_1
    

    class SubClass(SuperClass):
        sub_class_attr = {'six':6, 'seven':7}
    
        def __init__(self, param_1, param_2):
            super().__init__(param_1)
            self.sub_instance_attr = param_2

        def sub_instance_method(self):
            print('Called: sub_instance_method')
            print(self.super_instance_attr)
            print(self.sub_instance_attr)
    
        @classmethod
        def sub_class_method(cls):
            print('Called: sub_class_method')
            print(cls.super_class_attr)
            print(cls.sub_class_attr)
    

    sub = SubClass('param_1', 'param_2')
    
    print(sub.super_instance_attr)
    print(sub.sub_instance_attr)
    print('-' * 30)
    print(SubClass.super_class_attr)
    print(SubClass.sub_class_attr)
    print('-' * 30)
    sub.sub_instance_method()
    print('-' * 30)
    SubClass.sub_class_method()

::

    param_1
    param_2
    ------------------------------
    {'one': 1, 'two': 2}
    {'six': 6, 'seven': 7}
    ------------------------------
    Called: sub_instance_method
    param_1
    param_2
    ------------------------------
    Called: sub_class_method
    {'one': 1, 'two': 2}
    {'six': 6, 'seven': 7}


.. tip:: 

  از درس پیش مفهوم سازنده (Constructor) در شی گرایی را بیاد داریم. چنانچه در superclass متدهای سازنده (``__new__`` و  ``__init__``) پیاده‌سازی شده باشند، می‌بایست این متدها در subclass‌ها نیز پیاده‌سازی شوند، نیازی نیست که سرآیند تعریف این دو متد با superclass یکسان باشد ولی می‌بایست مقادیر مورد نیاز متد superclass فراهم شود. برای این کار لازم است داخل متد subclassها به superclass دسترسی داشه باشیم، تابع ``super`` [`اسناد پایتون <https://docs.python.org/3/library/functions.html#super>`__] این امکان را فراهم می‌کند.

خروجی  تابع ``super`` [`اسناد پایتون <https://docs.python.org/3/library/functions.html#super>`__] شی است که نقش واسط را بین دو کلاس subclass و superclass دارد. نمونه کد زیر چگونگی فراخوانی انواع متدهای superclass را از subclass نمایش می‌دهد:


.. code-block:: python
    :linenos:

    class SuperClass:
    
        def super_instance_method(self):
            print('Called: super_instance_method')
            print(self)
    
        @classmethod
        def super_class_method(cls):
            print('Called: super_class_method')
            print(cls)

        @staticmethod
        def super_static_method():
            print('Called: super_static_method')
    

    class SubClass(SuperClass):
    
        def sub_instance_method(self):
            super().super_instance_method()
            super().super_class_method()
            SuperClass.super_static_method()
    
        @classmethod
        def sub_class_method(cls):
            super().super_class_method()
            SuperClass.super_static_method()

        @staticmethod
        def sub_static_method():
            SuperClass.super_static_method()
    

    sub = SubClass()
    
    sub.sub_instance_method()
    print('-' * 30)
    SubClass.sub_class_method()
    print('-' * 30)
    SubClass.sub_static_method()

::

    Called: super_instance_method
    <__main__.SubClass object at 0x7f9c77052898>
    Called: super_class_method
    <class '__main__.SubClass'>
    Called: super_static_method
    ------------------------------
    Called: super_class_method
    <class '__main__.SubClass'>
    Called: super_static_method
    ------------------------------
    Called: super_static_method

می‌دانیم که مفسر پایتون به صورت خودکار اطلاعات مربوط به شی فراخوانی کننده یک Instance Method را فراهم می‌آورد. زمانی که یک Instance Method از subclass فراخوانی می‌شود، تابع ``super`` می‌تواند آن شی و از طریق آن شی نیز به کلاس دسترسی داشته باشد بنابراین از داخل Instance Method کلاس subclass می‌توان به واسطه تابع ``super`` به هر دو نوع Instance Methodها و Class Methodهای superclass دسترسی پیدا کرد، چرا که تابع ``super`` می‌تواند مقادیر ``self``  و ``cls`` را به منظور فراخوانی متدهای متناظر superclass به دست آورد.

همچنین می‌دانیم که در فراخوانی Class Method، تنها اطلاعات مربوط به کلاس فراهم است و نه شی. زمانی که یک Class Method از subclass فراخوانی می‌شود، تابع ``super`` می‌تواند به کلاس مرتبط دسترسی داشته باشد بنابراین از داخل Class Method کلاس subclass تنها می‌توان به واسطه تابع ``super`` به Class Methodهای superclass دسترسی پیدا کرد، چرا که تابع ``super`` تنها می‌تواند مقدار ``cls`` را به منظور فراخوانی متدهای متناظر superclass به دست آورد.

در زمان فراخوانی Static Method نیز می‌دانیم که مفسر پایتون هیچ اطلاعاتی از شی و کلاس مرتبط را فراهم نمی‌آورد، بنابراین فراخوانی این متد با استفاده از تابع ``super`` انجام نمی‌پذیرد. در صورت نیاز به فراخوانی Static Methodهای کلاس superclass در کلاس subclass، همواره می‌توانید از نام کلاس superclass بهره بگیرید.


.. note:: 

  این برنامه‌نویس است که تصمیم می‌گیرد یک کلاس چگونه طراحی شود. اینکه کدام متد باید از کدام نوع باشد مسئله‌ای است که برنامه‌نویس باید در زمان طراحی کلاس خود به آن فکر کند و از امکانات زبان برنامه‌نویسی پایتون به درستی در جهت بهتر و راحت‌تر به انجام رساندن مسئله خود بهره بگیرد.


.. tip:: 

  هر شی از یک کلاس علاوه بر اینکه از نوع آن کلاس محسوب می‌شود، از نوع superclass نیز به حساب می‌آید. در واقع یک شی نوع subclass، نوع superclass را نیز به ارث می‌برد::

       >>> class SuperClass:
       ...     pass
       ... 
       >>> class SubClass(SuperClass):
       ...     pass
       ... 
       >>> sub = SubClass()
       >>> 
       >>> isinstance(sub, SubClass)
       True
       >>> isinstance(sub, SuperClass)
       True


وراثت چندگانه (Multiple Inheritance)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

پایتون جزو معدود زبان‌های برنامه‌نویسی مدرنی است که از وراثت چندگانه پشتیبانی می‌کند، چیزی که در زبانی همچون Java نیز وجود ندارد. در واقع پیاده‌سازی وراثت چندگانه چالش‌هایی به همراه دارد، همانند Diamond Problem که در Java ترجیح داده شده است که از وراثت چندگانه پرهیز کند و نبود آن را با پیاده‌سازی مفهومی همچون Interface پوشش دهد [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Interface_(Java)>`__]. 

فراموش نکنیم در پیاده‌سازی شی گرایی می‌بایست بنابر نیاز برنامه کدهای خود را به کوچک‌ترین واحدهای ممکن تقسیم کنیم و اینکه یک شی بتواند صفات و رفتارهای چندین کلاس را به همراه خود داشته باشد یک نیاز اساسی در شی گرایی است. این الزام فلسفه سادگی پایتون است که مانع از آن می‌شود تا مفاهیمی موازی درکنار هم ایجاد شوند - همانند Class و Interface - وراثت چندگانه راه حل ساده و منطقی زبان برنامه‌نویسی پایتون برای حل این مشکل است و این امکان را می‌دهد که یک کلاس بتواند بیش از یک superclass داشته باشد:
::

    >>> class SuperClassA:
    ...     pass
    ... 
    >>> class SuperClassB:
    ...     pass
    ... 
    >>> class SuperClassC:
    ...     pass
    ... 
    >>> class SubClass(SuperClassA, SuperClassB, SuperClassC):
    ...     pass
    ... 
    >>> sub = SubClass()
    >>> 
    >>> isinstance(sub, SubClass)
    True
    >>> isinstance(sub, SuperClassA)
    True
    >>> isinstance(sub, SuperClassB)
    True
    >>> isinstance(sub, SuperClassC)
    True

نمونه کد بالا نمایش ساختار وراثت چندگانه در پایتون است که در آن کلاس SubClass به ترتیب از سه کلاس SuperClassA و SuperClassB و SuperClassC  ارث‌بری دارد. 

اکنون مهم‌ترین چالش چگونگی دسترسی به متدهای هر یک از این superclassها می‌باشد. تاکنون برای دسترسی به متدهای superclass از تابع  ``super``  استفاده می‌کردیم ولی حالا که صحبت از چندین superclass است، مثلا مقدارهی متد ``__init__`` توسط این تابع چگونه می‌تواند انجام شود؟ چگونه باید به پایتون بگوییم آرگومان‌هایی را که می‌خواهیم دقیقا به متد خاصی از superclass مورد نظر ارسال کند؟ البته نگران نباشید، پایتون مشکلی نخواهد داشت. در ادامه، حالات مختلف حل این مسئله را بررسی خواهیم کرد.

**شیوه یکم:** خیلی ساده، می‌توانیم اصلا از تابع ``super`` استفاده نکنیم و متدهای هر superclass را مستقیم با نام خودش فراخوانی کنیم که البته در این روش لازم است به ازای تمام پارامترهای متد superclass آرگومان متناظر را ارسال نماییم، از جمله برای ``self``:


.. code-block:: python
    :linenos:

    class SuperClassA:
        def __init__(self, param_0, param_3):  
            print('Called: SuperClassA.__init__()')
            self.param_0 = param_0
            self.param_3 = param_3
    
    
    class SuperClassB:
        def __init__(self, param_1):  
            print('Called: SuperClassB.__init__()')
            self.param_1 = param_1
    
    class SuperClassC:
        def __init__(self, param_2):  
            print('Called: SuperClassC.__init__()')
            self.param_2 = param_2
    
    
    class SubClass(SuperClassA, SuperClassB, SuperClassC):
        def __init__(self, param_0, param_1, param_2, param_3, param_4):  
            SuperClassA.__init__(self, param_0, param_3)
            SuperClassB.__init__(self, param_1)
            SuperClassC.__init__(self, param_2)
            self.param_4 = param_4
    
    
    sub = SubClass(0, 1, 2, 3, 4)
    
    print('param_0: ', sub.param_0)
    print('param_1: ', sub.param_1)
    print('param_2: ', sub.param_2)
    print('param_3: ', sub.param_3)
    print('param_4: ', sub.param_4)

::

    Called: SuperClassA.__init__()
    Called: SuperClassB.__init__()
    Called: SuperClassC.__init__()
    param_0:  0
    param_1:  1
    param_2:  2
    param_3:  3
    param_4:  4


    


**شیوه دوم:** رفتار تابع ``super`` را عمیق‌تر بشناسیم و درست از آن بهره بگیریم:

لازم است با **Method Resolution Order** یا به اختصار **MRO** در زبان برنامه‌نویسی پایتون آشنا شویم. همانطوری که از نام آن نیز مشخص است، **MRO** ترتیبی که می‌بایست بر اساس آن متدها به ارث برده شوند را مشخص می‌کند. پایتون برای این منظور از الگوریتم C3 linearization بهره گرفته است [`ویکی‌پدیا <https://en.wikipedia.org/wiki/C3_linearization>`__]. هر کلاس پایتون یک Special Attribute به اسم ``__mro__`` دارد که حاوی یک تاپل از ترتیب کلاس‌هایی است که در فرآیند MRO نقش دارند [`اسناد پایتون <https://docs.python.org/3/library/stdtypes.html#class.__mro__>`__]::


   >>> SubClass.__mro__
   (<class '__main__.SubClass'>, <class '__main__.SuperClassA'>, <class '__main__.SuperClassB'>, <class '__main__.SuperClassC'>, <class 'object'>)


می‌دانیم که هر کلاس پایتون به صورت پیش‌فرض از کلاس ``object`` ارث‌بری دارد. از طرفی در فرآیند وراثت چندگانه ترتیب نوشتن superclassها در سرآیند subclass مهم است به این صورت که MRO پایتون برای یافتن متد مورد نظر کلاس‌های superclass را به ترتیب از سمت چپ به راست مورد جستجو قرار می‌دهد (**depth-first left-to-right**)، ابتدا نخستین superclass از سمت چپ انتخاب و برسی می‌گردد، چنانچه آن کلاس نیز  superclass داشته باشد، برای آن نیز همین روند طی می‌شود تا به کلاس object برسد، سپس دومین superclass از سمت چپ انتخاب و همین روند تا بالاترین سطح برای آن پیمایش می‌شود و الی آخر::

     SubClass 
              --> SuperClassA --> object 
              --> SuperClassB --> object 
              --> SuperClassC --> object


.. code-block:: python
    :linenos:

    class SuperClassA:
        def __init__(self, param_0, param_3, *args):  
            print('Called: SuperClassA.__init__()')
            super().__init__(*args)
            self.param_0 = param_0
            self.param_3 = param_3
    
    
    class SuperClassB:
        def __init__(self, param_1, *args):  
            print('Called: SuperClassB.__init__()')
            super().__init__(*args)
            self.param_1 = param_1
    
    class SuperClassC:
        def __init__(self, param_2, *args): 
            print('Called: SuperClassC.__init__()')
            super().__init__(*args)
            self.param_2 = param_2
    
    
    class SubClass(SuperClassA, SuperClassB, SuperClassC):
        def __init__(self, param_0, param_1, param_2, param_3, param_4):  
            super().__init__(param_0, param_3, param_1, param_2)
            self.param_4 = param_4
    
    
    sub = SubClass(0, 1, 2, 3, 4)

.. code-block:: python
    :linenos:

    class SuperClassA:
        def __init__(self, param_0, param_3, **kargs):  
            print('Called: SuperClassA.__init__()')
            super().__init__(**kargs)
            self.param_0 = param_0
            self.param_3 = param_3
    
    
    class SuperClassB:
        def __init__(self, param_1, **kargs):  
            print('Called: SuperClassB.__init__()')
            super().__init__(**kargs)
            self.param_1 = param_1
    
    class SuperClassC:
        def __init__(self, param_2, **kargs): 
            print('Called: SuperClassC.__init__()')
            super().__init__(**kargs)
            self.param_2 = param_2
    
    
    class SubClass(SuperClassA, SuperClassB, SuperClassC):
        def __init__(self, p0, p1, p2, p3, p4):  
            super().__init__(param_0=p0, param_3=p3, param_1=p1, param_2=p2)
            self.param_4 = p4
    
    
    sub = SubClass(0, 1, 2, 3, 4)
  
انجمن (Association)
----------------------------------




ترکیب (Composition)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




تجمع (Aggregation)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <https://www.coderz.ir/python-tutorial-oop-class-and-object>`_



