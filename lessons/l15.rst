.. role:: emoji-size

.. meta::
   :description: کتاب آموزش زبان برنامه نویسی پایتون به فارسی، آموزش ماژول re در پایتون، عبارات باقاعده در پایتون، Regular expression در پایتون، regex در پایتون
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, تابع, کتابخانه, پایتون, re


درس ۱۵: کتابخانه استاندارد پایتون: Regular expression در پایتون - re
============================================================================

**عبارات با قاعده** (**Regular expression**) یا به اختصار **RegEx**، رشته‌ای حاوی کاراکترهایی خاص و با معنی است که در عملیات‌هایی مانند یافتن (find)، جاگذاری (repleace) و اعتبارسنجی (validation) به شدت کاربرد پیدا کرده است. در واقع با استفاده از RegEx می‌توان یک الگو (pattern) برای جستجو در متن یا تطابق آن ایجاد کرد.  [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Regular_expression>`__]

در این درس به شرح قواعد موجود در RegEx و همچنین ماژول ``re`` از کتابخانه استاندارد پایتون خواهیم پرداخت [`اسناد پایتون <https://docs.python.org/3/library/re.html>`__]. ماژول ``re`` یک مجموعه ابزار برای کار با RegEx در پایتون را فراهم آورده است که می‌توان آن را موتور تحلیل RegEx در پایتون دانست.





:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----

عبارات باقاعده
-----------------

قواعد «عبارات باقاعده» شامل استفاده و چیدمان تعدادی کاراکتر خاص می‌شود که در مجموع معنی یا الگویی را به وجود می‌آورند!. در ادامه در قالب دو دسته Matching Characters و Special Sequences به بررسی این کاراکترها می‌پردازیم.


کاراکترهای تطابق (Matching Characters)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

در عمل تطبیق (Match) با RegEx، اکثر حروف و کاراکتر‌ها معرف خود همان کاراکتر است. برای مثال کاراکتر ``a`` معرف ``a`` است و  کلمه ``test`` نیز با همان کلمه ``test`` تطابق یا همخوانی پیدا می‌کند. 


با این حال برخی از کاراکترها هستند که به جای همخوانی با خود، مفهوم دیگری را می‌رسانند که از آن‌ها با عنوان ``metacharacters`` (متاکاراکترها) یاد می‌شود [`اسناد پایتون <https://docs.python.org/3/howto/regex.html#matching-characters>`__] و عبارتند از::

  . ^ $ * + ? [] {} | () \


* Dot ``.``

  به معنی «هر کاراکتری» می‌باشد. یعنی وجود ``.`` در یک الگو (Pattern) باعث انجام عمل تطابق یا همخوانی با هر کاراکتری خواهد شد (به جز کاراکتر newline یا ``n\``).

  .. tip::
      به صورت پیش‌فرض ``.`` در الگوی RegEx کاراکتر newline را شامل نمی‌شود ولی در زبان برنامه‌نویسی پایتون می‌توان با نشانه‌گذاری ``re.DOTALL`` کاری کرد که کاراکتر newline را نیز شامل شود. *نمونه کد مربوط به این بحث در بخش بعدی بررسی خواهد شد.*

  به عنوان نمونه الگوی ``...`` هر سه کاراکتر متوالی را در بر می‌گیرد::

    ...


  ::

    'ab'          => no matche
    'abc1234'     => 2 matches ('abc', '123')
    '01267'       => 1 matche  ('012')
    'python'      => 2 matches ('pyt', 'hon')
    '2 0 85  ad'  => 3 matches ('2 0', ' 85', '  a')

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/7>`__]



* Caret ``^``

  در یک کاربرد در سمت چپ یک الگو قرار می‌گیرد و تعین کننده الزام شروع با آن الگو (Pattern) می‌باشد (*کاربرد دیگر آن در ادامه ذکر خواهد شد*).


  ::

    ^a


  ::

    'a'        => 1 matche ('a')
    'abc'      => 1 matche ('a')
    'bac'      => no matche ('a' is not in the start)

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/8>`__]


  ::

    ^ab

  ::

    'abc'           => 1 matche ('ab')
    'acb'           => no matche (starts with 'a' but not followed by 'b')
    'ab123 ab456'   => 1 matche ('ab' from ab123)


  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/10>`__]


* Dollar ``$``

  تعین کننده نقطه پایان تطابق الگو می‌باشد.


  ::

     a$
           a        => Matched
           formula  => Matched
           cab      => NO Match ('a' is not in the end)


  [`regex101@ تست آنلاین <https://regex101.com/r/wmx2cd/1>`__]

  ::

     ^s...d$
   
  به عنوان مثالی دیگر، الگوی بالا معرف هر کلمه پنج کاراکتری است که با کاراکتر ``s`` شروع و با کاراکتر ``d`` پایان می‌پذیرد.


* Star ``*``

  معرف **هیچ** یا **هر تعداد** تکرار الگوی سمت چپ خود می‌باشد.


  ::

     ma*n
           mn       => Matched
           man      => Matched
           maaan    => Matched
           main     => NO Match ('a' is not followed by 'n')
           woman    => Matched

  [`regex101@ تست آنلاین <https://regex101.com/r/HsZQ5b/1>`__]

* Plus ``+``

  معرف **یک** یا **هر تعداد** تکرار الگوی سمت چپ خود می‌باشد.


  ::

     ma+n
           mn       => NO Match (no 'a' character)
           man      => Matched
           maaan    => Matched
           main     => NO Match ('a' is not followed by 'n')
           woman    => Matched

  [`regex101@ تست آنلاین <https://regex101.com/r/1Y0lLa/1>`__]


* Question Mark ``?``

  معرف **هیج** یا **یک** تکرار الگوی سمت چپ خود می‌باشد.


  ::

     ma?n
           mn       => Matched
           man      => Matched
           maaan    => NO Match (more than one 'a' character)
           main     => NO Match ('a' is not followed by 'n')
           woman    => Matched

  [`regex101@ تست آنلاین <https://regex101.com/r/4opPeJ/1>`__]


* Square brackets ``[ ]``

  از دو کاراکتر ``[`` و  ``]`` برای بیان یک دسته یا بازه از کاراکترها استفاده می‌شود که برای این منظور می‌توان تک تک کاراکترها را به صورت صریح نوشت یا با استفاده از کاراکتر ``-`` به سادگی یک بازه را تعیین نمود.


  ::

     [abc]

  برای نمونه، الگوی بالا با هر رشته‌ای که حاوی کاراکتر‌های   ``b`` ،``a`` یا ``c`` باشد تطابق خواهد داشت [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/2>`__].


  ::

     [abc]
           a          => 1 Matched
           ac         => 2 Matched
           python     => NO Match
           abc de ca  => 5 Matched


  همانطور که بیان شد، با استفاده از کاراکتر ``-`` هر دو بخش روبرو در نمونه کد پایین با یکدیگر معادل و برابر هستند::

     [0-9]       ==    [0123456789]
     [1-4]       ==    [1234]
     [a-e]       ==    [abcde]
     [1-5a-e]    ==    [12345abcde]
     [0-39]      ==    [01239]
     [a-eA-E]    ==    [abcdeABCDE]


  .. note::
      باید توجه داشت RegEx ذاتا CASE SENSITIVE است و کوچک یا بزرگ بودن حروف انگلیسی در آن **تاثیر دارد**. با این حال زبان‌های برنامه‌نویسی از جمله پایتون امکاناتی را برای غیرفعال ساختن این وضعیت فراهم می‌آورند که در ادامه بررسی خواهد شد.


  **کاربرد دوم کاراکتر  ^ (Caret)**

  اکنون زمان آن رسیده است تا با کاربرد دوم کاراکتر Caret ``^`` آشنا شویم: با قرار دادن این کاراکتر به عنوان عضو ابتدای یک ``[ ]`` می‌توان عملکرد یا مفهوم آن را برعکس‌ یا در واقع NOT کرد! برای نمونه الگوی ``[abc^]`` به معنی تطابق با هر کاراکتری است به جز ``b`` ،``a`` و ``c``. [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/3>`__]



* Braces ``{ }``

  با ساختاری مشابه ``{n,m}`` به کار می‌رود که در آن ``n`` و ``m`` به ترتیب بیان کننده حداقل و حداکثر تعداد تکرار الگوی سمت چپ خود می‌باشند.


  ::

     a{2,3}
           abc dat      => NO Match
           abc daat     => 1 Matched (at d'aa't)
           aabc daaat   => 2 Matched (at 'aa'bc and d'aaa't)
           aabc daaaat  => 2 Matched (at 'aa'bc and d'aaa'at)


  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/4>`__]

  ::

     [0-9]{2,4}
           1          => NO Match
           ab123cde   => 1 Matched (at ab'123'cde)
           12         => 1 Matched
           123456789  => 2 Matched (at '1234' and '5678')
           1 2 3 4    => NO Match


  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/5>`__]


  چنانچه از ``{ }`` با ساختاری مشابه ``{n}`` به کار برود، مفهوم تعداد تکرار دقیق (لازم) الگوی سمت چپ خود را می‌رساند.


  ::

     [0-9]{3}
           1          => NO Match
           ab123cde   => 1 Matched (at ab'123'cde)
           12         => NO Match
           123456789  => 3 Matched (at '123' and '456' and '789')
           1 2 3 4    => NO Match

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/13>`__]



* Pipe ``|``

  این کاراکتر مفهومی معادلی عملگر ``OR`` (یا) دارد که معرف تطابق با الگوی سمت راست **یا** سمت چپ خود می‌باشد.


  ::

     a|b
           cde      => NO Match
           ade      => 1 Matched (at 'a'de)
           acdbea   => 3 Matched (at 'a'cd'b'e'a')

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/6>`__]



* Parentheses ``()``

  برای گروه‌بندی الگوها از پرانتز استفاده می‌شود یعنی می‌توان الگویی را با استفاده از یک یا چند زیرالگو (sub-patterns) ایجاد کرد.


  ::

     (a|b|c)xz

           ab xz      => NO Match
           abxz       => 1 Matched (at a'bxz')
           axz cabxz  => 2 Matched (at 'axz'bc ca'bxz')


  این الگو تمامی حروفی که شامل یکی از کاراکترهای ``a`` یا ``b`` یا ``c`` بوده و در ادامه ``xz`` باشد را تطبیق می‌دهد.

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/11>`__]




* Backslash ``\``

  از این کاراکتر برای بی‌اثر کردن مفهوم هر یک از metacharacters در الگو استفاده می‌شود. برای نمونه قرار گرفتن  ``*\`` در یک الگو، تنها خود کاراکتر ``*`` را تطبیق می‌دهد و به عبارتی دیگر کاراکتر ``*`` در این جا مفهوم الگویی خود (تکرار الگو سمت چپ) را از دست داده است.


  ::

     [0-9]\.[0-9]{2}

           3        => NO Match
           3.55     => 1 Matched (at '3.55')
           5.2      => NO Match
           7.37520  => 1 Matched (at '7.37')
           506.035  => 1 Matched (at '6.03')

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/12>`__]



توالی‌های ویژه (Special Sequences)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

در بحث عبارات باقاعده هنگامی که کاراکتر ``\`` به همراه یک کاراکتر مشخص (به شرح زیر) آورده شود، Special sequence خوانده می‌شود. Special sequences برای سهولت در نوشتن الگوها کاربرد دارند که برخی از پر کاربردترین آن‌ها عبارتند از::

  \A \b \B \d \D \s \S \w \W \Z




* ``A\``

  برای تعین شروع یک متن به کار می‌رود. برای نمونه، الگوی ``AThe\`` تمام رشته‌هایی که با ``The`` شروع شوند را تطبیق می‌دهد (یادآوری: در بحث RegEx، کوچک یا بزرگ بودن حروف دارای اهمیت است).

  ::

     \AThe

           The Rain        => Match
           In The Rain     => NO Match

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/14>`__]


  .. note::
      تفاوت ``A\`` و کاربرد یکم ``^``: در متن‌های چند سطری مشاهده می‌شود به گونه‌ای که  ``A\`` به ابتدای کل آن متن و ``^`` به ابتدای هر سطر از متن اشاره می‌کنند.




* ``b\``

  بر حسب موقعیت قرار گرفتن، شروع یا پایان یک **کلمه** را مشخص می‌کند. 

  ::

     \bunder

           understand        => Match
           underworld        => Match
           Underworld        => NO Match
           TheUnderworld     => NO Match

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/16>`__]



  ::

     ing\b

           Driving        => Match
           Spring         => Match
           spring_day     => NO Match

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/17>`__]


* ``B\``

  برعکس ``b\``، بر حسب موقعیت قرار گرفتن، شروع یا پایان **نیافتن** یک **کلمه** را مشخص می‌کند. یعنی کلماتی را تطبیق می‌دهد که با کاراکتر یا کارکترهایی مشخصی شروع یا پایان نیافته باشند.

  ::

     \Bunder

           understand        => NO Match
           underworld        => NO Match
           Underworld        => NO Match
           Thunderbird       => Match

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/18>`__]


  ::

     ball\B

           Football        => NO Match
           Footballist     => Match

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/19>`__]


* ``d\``

  معادل ``[9-0]``

  ::

     \d{3,5}

           1                     => NO Match
           123                   => 1 Matched (at '123')
           123456                => 1 Matched (at '12345')
           1237 Main Street,     => 1 Matched (at '1237')

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/20>`__]



* ``D\``

  برعکس ``d\`` - معادل ``[9-0^]``، یعنی تمامی کاراکترهای غیر عددی را تطبیق می‌دهد.

  ::

     \D{3,5}

           1                     => NO Match
           123                   => NO Match
           123456                => NO Match
           1237 Main Street,     => 3 Matched (at ' Main', ' Stre', 'et,')

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/21>`__]


* ``s\``

  معادل ``[t\n\r\f\v\ ]``، به معنی عمل تطبیق با کاراکتر فضای خالی است.

  ::

     \s

           1237 Main Street,     => 2 Matched (2 spaces)

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/23>`__]




  البته باید توجه داشته که منظور از کاراکترهای ``t \n \r \f \v\`` همان Escape character هستند [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Escape_character>`__].

  ::

      \n ---> new line
      \r ---> carriage return
      \t ---> tab
      \v ---> vertical tab
      \f ---> form feed






* ``S\``

  برعکس ``s\`` - معادل ``[t\n\r\f\v\ ^]``، به معنی عمل تطبیق با هر کاراکتری غیر از فضای خالی است.

  ::

     \S{2,5}

           1237 Main Street,     => 4 Matched (at '1237', 'Main', 'Stree', 't,')

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/24>`__]


* ``w\``

  معادل ``[_a-zA-Z0-9]``، به معنی عمل تطبیق با کاراکترهای الفبایی و عددی (زبان انگلیسی) به همراه کاراکتر ``_`` یا underscore.

  ::

     \w{2,5}

           1237 Main Street,     => 3 Matched (at '1237', 'Main', 'Stree')

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/25>`__]


* ``W\``

  برعکس ``w\`` - معادل ``[_a-zA-Z0-9^]``، به معنی عمل تطبیق با کاراکتری به غیر از کاراکترهای الفبایی و عددی (زبان انگلیسی) به همراه کاراکتر ``_`` یا underscore.

  ::

     \W

           1237 Main Street,     => 3 Matched (2 spaces and ',')

  [`regex101@ تست آنلاین <https://regex101.com/r/IIc4Fh/26>`__]




* ``Z\``

  برای تعین پایان یک متن به کار می‌رود. برای نمونه، الگوی ``Rain\Z`` تمام رشته‌هایی که با ``Rain`` پایان یابند را تطبیق می‌دهد (یادآوری: در بحث RegEx، کوچک یا بزرگ بودن حروف دارای اهمیت است).

  ::

     Rain\Z

           The Rain     => Match

  [`regex101@ تست آنلاین <https://regex101.com/r/GKdjqw/1>`__]  [`regex101@ تست آنلاین <https://regex101.com/r/a9KkLb/1>`__]


  .. note::
      تفاوت ``Z\`` و ``$``: در متن‌های چند سطری مشاهده می‌شود به گونه‌ای که  ``Z\`` به انتهای کل آن متن و ``$`` به انتهای هر سطر از متن اشاره می‌کنند.




ماژول re پایتون
-----------------

آنچه از عبارات باقاعده تاکنون آشنا شدیم تنها شامل تعدادی تعاریف و قواعد بودند که برای استفاده و به کار بردن آنها در زبان‌های برنامه‌نویسی نیاز به ابزارهایی می‌باشد. همچنین باید توجه داشت انجام تمامی امور مربوط به پردازش متن را نباید از عبارات باقاعده انتظار داشت چرا که این قواعد هم محدودیت‌های خاص خود را دارد و در مواردی ممکن است الگوی ایجاد شده چنان پیچیده گردد که از خوانایی برنامه کاسته شود.

در زبان برنامه‌نویسی پایتون از طریق ماژول ``re`` از کتابخانه استاندارد آن، ثابت‌ها (constants) و توابع (functions) کاربردی بسیاری در زمینه عبارت باقاعده فراهم آورده شده است. در ادامه به بررسی برخی این از این توابع و نکات پیرامون آن‌ها خواهیم پرداخت.


تابع ``compile`` و  شی RegEx  پایتونی
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``re.compile(pattern, flags=0)``

تابع ``compile`` یک الگوی RegEx را کامپایل و یک شی RegEx پایتونی [`اسناد پایتون <https://docs.python.org/3/library/re.html#regular-expression-objects>`__] برمی‌گرداند. [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.compile>`__]

این تابع دو پارامتر دارد: ``pattern`` که معرف الگو RegEx مورد نظر می‌باشد و ``flags`` که با توجه به داشتن مقدار پیش‌فرض ``0``، ارسال آن اختیاری است.

پیش از ادامه با این تابع، بهتر است با مقادیر مجاز برای پارامتر ``flags`` آشنا شویم، چرا که این پارامتر اختیاری در توابع دیگری از ماژول ``re`` نیز مورد استفاده قرار گرفته است. در واقع با استفاده از این پارامتر می‌توان چگونگی پردازش الگو را دستخوش تغییراتی ساخت که گاهی ممکن است بسیار کارگشا باشند.  [`اسناد پایتون <https://docs.python.org/3/howto/regex.html#compilation-flags>`__]:


      * ``re.I`` یا ``re.IGNORECASE``

       نادیده گرفتن حروف کوچک یا بزرگ - یعنی صرف نظر از اینکه در الگوی مورد نظر از کاراکتر بزرگ استفاده شده باشد یا کوچک، عمل انطباق با آن کاراکتر صورت پذیرد. [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.IGNORECASE>`__]
 


      * ``re.M`` یا ``re.MULTILINE``

       سطرها در نظر گرفته شوند - در حالت عادی کاراکترهای تطابق ``^`` و ``$`` در الگو RegEx مشخص کننده ابتدا و انتهای یک رشته یا متن می‌باشند. فارغ از اینکه متن مورد نظر می‌تواند شامل چندین سطر باشد عمل تطابق با کل متن به انجام می‌رسد. اما با استفاده از این flag می‌توان مفهوم سطر را نیز پر رنگ کرد، به این صورت که: کاراکتر ``^`` مشخص کننده ابتدای هر سطر و کاراکتر ``$`` نیز مشخص کننده انتهای هر سطر خواهد بود. [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.MULTILINE>`__]



      * ``re.S`` یا ``re.DOTALL``

       کاراکتر ``.`` شامل تمامی کاراکترها باشد - در حالت عادی این کاراکتر عمل تطابق با کاراکتر سطر جدید ``n\`` را شامل نمی‌شود که با استفاده از این flag این ویژگی به الگو اضافه می‌گردد. [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.DOTALL>`__]
 



      * ``re.X`` یا ``re.VERBOSE``

       الگو حاوی توضیح (Comment) است - با استفاده از این flag می‌توان توضیح را به الگو اضافه کرد که نقش زیادی در بالا بردن خوانایی و درک الگو ایجاد می‌کند. [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.VERBOSE>`__]
 


      .. tip::
             می‌توان با استفاده از کاراکتر ``|`` در زمان ارسال آرگومان به flags، همزمان چندین مقدار را تنظیم نمود. به مانند: ``re.compile(pattern, re.I | re.M)``


             پارامتر flags می‌تواند مقادیر دیگری نیز بپذیرد که برای مطالعه بیشتر می‌توانید به مستندات پایتون مراجعه نمایید.


به تابع ``compile`` برمی‌گردیم::


    >>> # Python 3.x
    >>> 
    >>> import re
    >>> 
    >>> pattern = re.compile("^<html>", re.I)
    >>> 
    >>> type(pattern)
    <class 're.Pattern'>
    >>> 
    >>> print(pattern)
    re.compile('^<html>', re.IGNORECASE)


:: 

          >>> # Python 2.x
          >>> 
          >>> import re
          >>> 
          >>> pattern = re.compile("^<html>", re.I)
          >>> 
          >>> type(pattern)s
          <type '_sre.SRE_Pattern'>
          >>> 
          >>> print pattern
          <_sre.SRE_Pattern object at 0x7f22cf27ac00>


کاربرد تابع ``compile`` زمانی است که می‌خواهیم از یک الگو مشخص چندین بار در طول اجرای یک ماژول استفاده نماییم. در ادامه با توابع دیگری از ماژول ``re`` آشنا خواهیم شد؛ این توابع پیش از انجام وظیفه مربوط به خود، به صورت ضمنی الگو را به شی ``re.Pattern`` یا ``sre.SRE_Pattern_`` (در پایتون 2x) کامپایل می‌کنند که به این صورت می‌توان کارایی برنامه را با یک بار ``compile`` افزایش دهیم. البته باید اشاره کرد که مفسر پایتون به صورت خودکار نمونه کامپایل شده چند الگو آخر مورد استفاده را Cache می‌کند، بنابراین چنانچه در برنامه‌ خود از تعداد اندکی الگو استفاده می‌کنید، می‌توانید در این زمینه نگران کارایی نباشید.

یادآوری شود که با استفاده از تابع ``dir`` می‌توانیم متدها و صفت‌های شی الگو را مشاهده نماییم::

      >>> dir(pattern)  #  Python 3.x
      ['__class__', '__copy__', '__deepcopy__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'findall', 'finditer', 'flags', 'fullmatch', 'groupindex', 'groups', 'match', 'pattern', 'scanner', 'search', 'split', 'sub', 'subn']
      >>> 

توابع جستجو 
~~~~~~~~~~~~~~~~~~~~~

توابع پرکاربرد ماژول ``re``، مرتبط با عمل جستجو در متن، عبارتند از: ``finditer``  ``findall``  ``fullmatch``  ``match``  ``search`` که در بخش‌های بعدی به شرح هریک پرداخته خواهد شد.


تابع ``search``
~~~~~~~~~~~~~~~~~~~~~~


``search(pattern, string, flags=0)``

تابع ``search`` به دنبال اولین انطباق pattern در string می‌گردد، در صورت موفقیت یک شی ``Match`` [`اسناد پایتون <https://docs.python.org/3/library/re.html#match-objects>`__] و در غیر این صورت ``None`` برمی‌گرداند [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.search>`__]::


    >>> # Python 2.x
    >>> 
    >>> import re
    >>> 
    >>> match = re.search('Py...n', 'Python is great')
    >>> 
    >>> type(match)
    <type '_sre.SRE_Match'>
    >>> 

::


    >>> # Python 3.x
    >>> 
    >>> import re
    >>> 
    >>> match = re.search('Py...n', 'Python is great')
    >>> 
    >>> type(match)
    <class 're.Match'>


اجازه بدهید یاد آوری کنیم که دو نمونه کد زیر عملکردی معادل یکدیگر دارند::


    >>> pattern = re.compile('Py...n')
    >>> match = pattern.search('Python is great')

::

    >>> match = re.search('Py...n', 'Python is great')



شی ``Match`` پایتون
~~~~~~~~~~~~~~~~~~~~~~~~~~~~


::

    >>> pattern = re.compile('Py...n')
    >>> match = pattern.search('Python is great')
    >>> 
    >>> if match:
    ...     print(match.group())
    ... else:
    ...     print("pattern not found")
    ... 
    Python
    >>> 

::

    >>> dir(match)
    ['__class__', '__copy__', '__deepcopy__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'end', 'endpos', 'expand', 'group', 'groupdict', 'groups', 'lastgroup', 'lastindex', 'pos', 're', 'regs', 'span', 'start', 'string']

در ادامه به بررسی برخی از متدهای مهم این شی می‌پردازیم:
  

 * ``Match.group([group1, ...])`` [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.Match.group>`__]

  این متد از شی ``Match`` گروه (های) تطبیق داده شده بر اساس الگو مورد نظر را برمی‌گرداند. این متد می‌تواند یک یا چند آرگومان عددی دریافت کند که معرف اندیس گروه مورد نظر می‌باشد. در حالت فراخوانی بدون آرگومان تمامی گروه‌های تطبیق داده شده به صورت یک مقدار رشته برگردانده می‌شود و در صورتی تنها یک مقدار به آن ارسال گردد، گروه تطبیق داده شده متناظر با آن اندیس (شمارش اندیس‌ها از یک است) در قالب یک شی رشته برگردانده می‌شود و در صورتی که بیش از یک اندیس به عنوان آرگومان ارسال گردد یک شی تاپل محتوی گروه‌های تطبیق داده شده برگردانده خواهد شد. چنانچه آرگومان ارسالی عددی منفی باشد یا اندیسی بالاتر از تعداد گروه‌های تطبیق داده شده باشد، یک استثنا ``IndexError`` رخ خواهد داد::

    >>> m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist") 
    >>> m.group()        # The entire match
    'Isaac Newton'
    >>> m.group(0)       # The entire match
    'Isaac Newton'
    >>> m.group(1)       # The first parenthesized subgroup.
    'Isaac'
    >>> m.group(2)       # The second parenthesized subgroup.
    'Newton'
    >>> m.group(1, 2)    # Multiple arguments give us a tuple.
    ('Isaac', 'Newton')

    >>> m.group(3)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    IndexError: no such group


  * ``Match.groups(default=None)`` [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.Match.groups>`__]

  این متد از شی ``Match`` تمام گروه‌های تطبیق داده شده بر اساس الگو مورد نظر را در قالب یک شی تاپل برمی‌گرداند. این متد می‌تواند یک آرگومان بپذیرد که معرف مقدار پیش‌فرض برای جایگذاری گروه‌هایی است در درشته ورودی تطبیق داده نشده اند، در حالت عادی (بدون ارسال آرگومان) این مقدار برابر با ``None`` است::

    >>> m = re.match(r"(\d+)\.(\d+)", "24.1632")
    >>> m.groups()
    ('24', '1632')

  ::

       >>> m = re.match(r"(\d+)\.?(\d+)?", "24")
       >>> m.groups()      # Second group defaults to None.
       ('24', None)
       >>> m.groups('0')   # Now, the second group defaults to '0'.
       ('24', '0')

  * ``Match.start([group])`` [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.Match.start>`__]    ``Match.end([group])`` [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.Match.end>`__]

  متن رشته خروجی (تطبیق یافته بر اساس الگو مورد نظر) را در نظر بگیرید، متد ``start`` اندیس شروع این متن از رشته ورودی و متد ``end``  اندیس نقطه پایان را برمی‌گردانند. این دو متد می‌توانند یک آرگومان اختیاری نیز دریافت کنند که معرف اندیس یک گروه مشخص در الگو می‌باشد، با ارسال این آرگومان نتایج بر اساس تکه متن تطبیق داده شده با آن گروه برگردانده خواهد شد::

    >>> email = "tony@tiremove_thisger.net"
    >>> m = re.search("remove_this", email)
    >>> m.start()
    7
    >>> m.end()
    18
    >>> email[m.start() : m.end()]
    'remove_this'
    >>> email[:m.start()] + email[m.end():]
    'tony@tiger.net'

  ::

       >>> m = re.match(r"(\d+)\.(\d+)", "24.1632")

       >>> m.start()
       0
       >>> m.end()
       7

       >>> m.start(1)
       0
       >>> m.end(1)
       2

       >>> m.start(2)
       3
       >>> m.end(2)
       7
       >>> 


  * ``Match.span([group])`` [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.Match.span>`__]

  این متد یک شی تاپل دوتایی از خروجی دو متد ``start``  و ``end``  را بر می‌گرداند ``(m.start(group), m.end(group))`` و همانند آنها یک آرگومان اختیاری دارد::

    >>> m.span()
    (0, 7)
    >>> m.span(1)
    (0, 2)
    >>> m.span(2)
    (3, 7)
    >>> m.span(3)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    IndexError: no such group

  * ``Match.re`` [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.Match.re>`__]    ``Match.string`` [`اسناد پایتون <https://docs.python.org/3/library/re.html#re.Match.string>`__]

  این دو متغیر به ترتیب حاوی  شی RegEx الگو و متن ارسال شده به دو متد ``search``  و ``match`` خواهند بود::

    >>> email = "tony@tiremove_thisger.net"
    >>> m = re.search("remove_this", email)

    >>> m.re
    re.compile('remove_this')

    >>> m.string
    'tony@tiremove_thisger.net'
    >>> m.string[m.start() : m.end()]
    'remove_this'

  ::

       >>> m = re.match(r"(\d+)\.(\d+)", "24.1632")

       >>> m.re
       re.compile('(\\d+)\\.(\\d+)')

       >>> m.string
       '24.1632'






|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <http://www.coderz.ir/python-tutorial-re-regex/>`_



