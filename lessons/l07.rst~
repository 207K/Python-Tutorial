.. role:: emoji-size

.. meta::
   :description: کتاب آنلاین و آزاد آموزش زبان برنامه‌نویسی پایتون به فارسی - درس هفتم انواع شی در پایتون
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, 


درس ۰۷: انواع شی آماده
=======================


:emoji-size:`✔` سطح: مقدماتی

----

انواع عددی
------------
در زبان پایتون دسته‌ای از انواع اشیا وجود دارد که به عنوان «انواع عددی» (Numeric Types) شناخته می‌شوند. این انواع اشیا عبارتند از:

* صحیح (Integer)
* ممیز شناور (Floating-Point)
* مختلط (Complex)
* دسیمال (Decimal)
* کسر (Fraction)
* بولی (Boolean)

*در ادامه به بررسی هر یک خواهیم پرداخت.*

صحیح
~~~~~~
این نوع از اشیا تمام اعداد مثبت و منفی بدون «ممیز اعشار» را شامل می‌شوند؛ مانند: ``1234``، ``26-`` و...

*بیان نوع عدد صحیح از نکات اختلافی در نسخه‌های 2x و 3x می‌باشد.* 

**در نسخه‌های 2x** اعداد صحیح در قالب دو نوع ``int`` (با اندازه ۳۲ بیت) و ``long`` (بدون محدودیت اندازه) بیان می‌شوند::

    >>> a = 3
    >>> type(a)
    <type 'int'>

    >>> b = 3L
    >>> type(b)
    <type 'long'>

به این صورت که اگر عدد صحیحی با حرف ``L`` (اِل بزرگ) یا ``l`` (اِل کوچک) پایان یابد؛ به صورت نوع ``long`` در نظر گرفته خواهد شد. البته توجه داشته باشید چنانچه در نوع ``int`` سرریز (`Overflow <https://en.wikipedia.org/wiki/Arithmetic_overflow>`_) رخ دهد؛ خطایی به وجود نخواهد آمد و پایتون به صورت خودکار شی نوع ``int`` را به شی‌ای از نوع ``long`` تبدیل (Convert) خواهد کرد.

**در نسخه‌های 3x** اعداد صحیح تنها در قالب یک نوع ``int`` (بدون محدودیت اندازه) ارایه می‌گردد و باید توجه داشت که استفاده از حرف ``L`` (یا ``l``) در پایان اعداد صحیح مجاز نمی‌باشد::

    >>> a = 3
    >>> type(a)
    <class 'int'>
    
    >>> b = 3L
      File "<stdin>", line 1
        b = 3L
             ^
    SyntaxError: invalid syntax
    >>> 

.. note::
    منظور از اندازه نامحدود اعداد این است که اندازه این اشیا تنها محدود به میزان حافظه (Memory) آزاد بوده و تا هر اندازه‌ای که حافظه در دسترس باشد می‌توانند در محاسبات رشد داشته باشند.

در هر دو شاخه از پایتون؛ اعداد صحیح را می‌توان علاوه بر مبنای ده؛ در مبنای دو (Binary)، مبنای هشت (Octal) و مبنای شانزده (Hexadecimal) نیز در نظر گرفت. به این صورت که:

* **اعداد مبنای دو** می‌بایست با یک ``0b`` یا ``0B`` (صفر و حرف بی کوچک یا بزرگ) آغاز گردند؛ مانند: ``0b11`` که برابر عدد ``3`` در مبنای ده است::

    >>> a = 0b11
    >>> type(a)
    <class 'int'>
    >>> a
    3


* **اعداد مبنای هشت** می‌بایست با یک ``0o`` یا ``0O`` (صفر و حرف اُ کوچک یا بزرگ) آغاز گردند؛ مانند: ``0o14`` که برابر عدد ``12`` در مبنای ده است::

    >>> a = 0o14
    >>> type(a)
    <class 'int'>
    >>> a
    12

  همچنین در **نسخه‌های 2x** برای مشخص کردن عددی در این مبنا می‌توان به جای ``0o`` یا ``0O``، تنها از یک صفر ``0`` استفاده کرد::

      >>> 0o14    # Python 3.x and Python 2.x
      12

      >>> 014     # Python 2.x
      12


* **اعداد مبنای شانزده** می‌بایست با یک ``0x`` یا ``0X`` (صفر و حرف اِکس کوچک یا بزرگ) آغاز گردند؛ مانند: ``0xA5`` که برابر عدد ``165`` در مبنای ده است::

    >>> a = 0xA5
    >>> type(a)
    <class 'int'>
    >>> a
    165

همانطور که در نمونه کدهای بالا نیز قابل مشاهده است؛ نوع شی صحیح در مبناهای گوناگون تفاوتی نمی‌کند (همان ``int`` است) و در پایتون تنها از یک سینتکس متفاوت برای مشخص کردن آن‌ها استفاده شده است. همچنین علاوه بر وارد کردن این اشیا در حالت تعاملی؛ دستور (یا تابع) ``print`` نیز این اشیا را در مبنای ده چاپ می‌‌کند::

    >>> a = 0xA5     # Python 2.x
    >>> type(a)
    <type 'int'>
    >>> a
    165
    >>> print a
    165


برای تبدیل یک عدد صحیح در مبنای ده به هر یک از این مبناها می‌توانید از تابع‌های آماده ``()int`` برای تبدیل به مبنای دو، ``()oct`` برای تبدیل به مبنای هشت و ``()hex`` برای تبدیل به مبنای شانزده استفاده نمایید. تنها توجه داشته باشید که خروجی هر یک از این تابع‌ها به صورت یک شی از نوع رشته یا String برگردانده می‌شود و نه یک نوع عددی::

    >>> a = 3
    >>> b = bin(a)
    >>> b
    '0b11'
    >>> type(b)
    <class 'str'>

    >>> a = 12
    >>> b = oct(a)
    >>> b
    '0o14'
    >>> type(b)
    <class 'str'>

    >>> a = 165
    >>> b = hex(a)
    >>> b
    '0xa5'
    >>> type(b)
    <class 'str'>

برای برگرداندن اعداد صحیح به مبنای ده می‌توان از تابع ``()int`` استفاده کرد. الگوی این تابع به صورت ``(int(str, base`` می‌باشد؛ این تابع یک رشته عددی یعنی یک عدد صحیح (در هر مبنایی) را به صورت رشته - داخل نمادهای نقل قول (Quotation) - در جایگاه آرگومان یکم، به همراه یک مقدار عددی که بیانگر مبنا (Base) عدد مورد نظر (یا همان آرگومان یکم) است را دریافت می کند و یک عدد (یک شی ``int``) متناظر با آرگومان یکم را در مبنای ده برمی‌گرداند::

    >>> a = 165

    >>> type(a)
    <class 'int'>

    >>> b = hex(a)
    >>> b
    '0xa5'

    >>> type(b)
    <class 'str'>

    >>> int(b, 16)
    165

    >>> type(int(b, 16))
    <class 'int'>



توجه داشته باشید که می‌توان اعداد را بدون حرف مشخص کننده مبنا (``0x`` ``0o`` ``0b``) به این تابع ارسال کنیم. همچنین از این تابع می‌توان برای تبدیل **نوع** رشته‌های عددی در مبنای ده به اعداد صحیح استفاده کرد. مقدار پیش‌فرض مبنا در این تابع عدد ``10`` است؛ بنابراین در هنگام ارسال اعداد در این مبنا، نیازی به ذکر مبنا ``10`` نمی‌باشد::


    >>> int("A5", 16)
    165

::

    >>> a = "56"
    >>> int(a, 10)
    56
    >>> int(a)
    56

::

    >>> int()
    0

*تابع ()int بدون آرگومان یک شی صفر از نوع صحیح را برمی‌گرداند.*

.. note::
    منظور از «رشته عددی»، رشته‌ای است که به گونه‌ای بتوان آن را به یک عدد ارزیابی نمود. مانند: ``"25"``، ``"0x2F"`` و... که بدیهی است فرستادن رشته‌هایی همچون ``"0w55"`` و... - که به هیچ شکلی نمی‌توان آن‌ها را به عددی در پایتون ارزیابی نمود - به تابع ``()int`` موجب بروز خطا می‌گردد.

با تفاوت شیوه بیان نوع اعداد صحیح در بین نسخه‌های 2x و 3x پایتون آشنا شده ایم. فقط باید توجه داشت که در **نسخه‌های 2x**  پایتون؛ تابع ``()int`` یک شی از نوع ``int`` (با اندازه ۳۲ بیت) را برمی‌گرداند و برای ایجاد اشیایی از نوع ``long`` تابعی مشابه دیگری با نام ``()long`` در دسترس است::

    >>> a = 25     # Python 2.x

    >>> int(a)
    25

    >>> long(a)
    25L

.. note::
    در هر دو شاخه از پایتون - اعداد در مبنای ده را می‌توان به همان نوع عدد به تابع ``()int`` (یا ``()long``) ارسال نمود.

ممیز شناور
~~~~~~~~~~~
تمام اعداد مثبت و منفی که شامل یک «ممیز اعشار» هستند در پایتون به صورت اشیایی با نوع ``float`` (با اندازه ۶۴ بیت) ارایه می‌شوند؛ مانند: ``3.1415``، ``.5`` (برابر ``5.0``) و... ::

    >>> a = 3.1415     # Python 3.x
    >>> type(a)
    <class 'float'>

گاهی برای نمایش اعداد از شیوه «نماد علمی» (`Scientific Notation <https://en.wikipedia.org/wiki/Scientific_notation>`_) استفاده می‌شود؛ در پایتون هم می‌توان از حرف ``E`` یا ``e`` که معادل «ضرب در ۱۰ به توانِ» می‌باشد، برای این منظور استفاده کرد.

.. raw:: html

    <div style="text-align:justify;margin-bottom:24px">برای نمونه: عبارت <code class="docutils literal"><span dir="ltr">4 × 10<sup>5</sup></span></code>، به شکل <code class="docutils literal">4E5</code> یا <code class="docutils literal">4e5</code> بیان می‌شود. پایتون این نوع اعداد را نیز در قالب اعداد ممیز شناور (اشیایی از نوع <code class="docutils literal">float</code>) ارايه می‌دهد:</div>

::

    >>> 3e2
    300.0

    >>> type(3e2)
    <class 'float'>

    >>> 3e-2
    0.03

    >>> 3e+2
    300.0

می‌توان از تابع ``()float`` برای تبدیل اعداد یا رشته‌های عددی به یک عدد ممیز شناور استفاده کرد::

    >>> a = 920

    >>> type(a)
    <class 'int'>

    >>> float(a)
    920.0

    >>> type(float(a))
    <class 'float'>

    >>> float("920")
    920.0

    >>> float("3e+2")
    300.0

::

    >>> float()
    0.0

*تابع ()float بدون آرگومان یک شی صفر از نوع ممیز شناور را برمی‌گرداند.*

چنانچه عددی از نوع ممیز شناور به تابع ``()int`` ارسال شود؛ بخش صحیح عدد برگردانده می‌شود::

    >>> a = 2.31
    >>> type(a)
    <class 'float'>

    >>> int(a)
    2
    >>> type(int(a))
    <class 'int'>

    >>> int(3.9)
    3

با استفاده از تابع ``()float`` می‌توانیم اشیایی با مقدارهای مثبت و منفی «بی‌نهایت» (infinity) و «تعریف نشده» (Not a Number یا NaN) ایجاد نماییم::

    >>> a = float('infinity')
    >>> a = float('inf')
    >>> a
    inf

    >>> b = float('-infinity')
    >>> b = float('-inf')
    >>> b
    -inf

    >>> c = float('NaN')
    >>> c
    nan

::

    >>> a = float('inf')

    >>> 5 / a
    0.0

    >>> a / a
    nan

::

    >>> a = float('inf')
    >>> b = float('inf')
    >>> a == b
    True

    >>> a = float('nan')
    >>> b = float('nan')
    >>> a == b
    False

*دو شی NaN با یکدیگر برابر نیستند.*

برای بررسی اینکه مقدار یک شی بی‌نهایت یا تعریف نشده است؛ می‌توان از تابع‌های ``()isinf`` و ``()isnan`` درون ماژول ``math`` استفاده نماییم::

    >>> a = float('inf')
    >>> b = float('nan')

    >>> import math

    >>> math.isinf(a)
    True
    >>> math.isnan(b)
    True


مختلط
~~~~~~~
همانطور که می‌دانیم اعداد مختلط (`Complex Numbers <https://en.wikipedia.org/wiki/Complex_number>`_) از یک بخش حقیقی (Real) و یک بخش موهومی (Imaginary) تشکیل شده‌اند. این اعداد در پایتون الگویی برابر ``RealPart + ImaginaryPart j`` دارند که حرف ``j`` نشانگر «واحد موهومی» است. این اعداد در پایتون توسط اشیایی با نوع ``complex`` ارایه می‌شوند::

    >>> a = 3 + 4j
    >>> type(a)
    <class 'complex'>


از تابع ``()complex`` می‌توان برای ایجاد یک شی ``complex`` استفاده نمود. این تابع الگویی مشابه ``(complex(real, imag`` دارد؛ آرگومان‌های نمونه real و imag بیانگر اعدادی هستند که به ترتیب قرار است در بخش‌های حقیقی و موهومی عدد مختلط مورد نظر وجود داشته باشند. اگر هر کدام از آرگومان‌ها ارسال نگردند به صورت پیش‌فرض صفر در نظر گرفته می‌شوند::

    >>> a = 3
    >>> b = 4

    >>> type(a)
    <class 'int'>
    >>> type(b)
    <class 'int'>

    >>> complex(a, b)
    (3+4j)

    >>> type(complex(a, b))
    <class 'complex'>

::

    >>> complex(3, 4)
    (3+4j)

    >>> complex(3)
    (3+0j)

    >>> complex(0, 4)
    4j

    >>> complex(4j)
    4j

::

    >>> a = 3 + 4j
    >>> a
    (3+4j)

    >>> a = 3.2 + 4j
    >>> a
    (3.2+4j)

    >>> a = 3.0 + 4j
    >>> a
    (3+4j)

    >>> a = 3.0 + 4.0j
    >>> a
    (3+4j)

همچنین با استفاده از دو صفت ``real`` و ``imag`` می‌توان بخش‌های حقیقی و موهومی هر شی ``complex`` را به دست آورد. توجه داشته باشید که جدا از این که اعداد از چه نوعی در تشکیل یک نوع مختلط شرکت کرده باشند؛ بخش‌های عدد مختلط به صورت عدد ممیز شناور تفکیک می‌گردند::

    >>> a = 3 + 4j

    >>> a.real
    3.0
    >>> a.imag
    4.0

تابع ``()complex`` توانایی دریافت یک رشته عددی و تبدیل آن به عدد مختلط را نیز دارد. تنها باید توجه داشت که نباید داخل این رشته هیچ فضای خالی وجود باشد::

    >>> a = "3+4j"

    >>> type(a)
    <class 'str'>

    >>> complex(a)
    (3+4j)

    >>> a = "3"
    >>> complex(a)
    (3+0j)

    >>> type(complex(a))
    <class 'complex'>

::

    >>> a = "3 + 4j"
    >>> complex(a)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    ValueError: complex() arg is a malformed string
    >>> 

.. note::
    امکان ارسال رشته عددی (مختلط) یا خود شی عدد مختلط به تابع‌های ``()int`` (یا ``()long``) و ``()float`` وجود ندارد و موجب بروز خطا می‌شود.

دسیمال
~~~~~~~~
اساس طراحی این نوع برای استفاده در مواقعی است که خطا نوع ممیز شناور قابل گذشت نیست [`PEP 327 <http://www.python.org/dev/peps/pep-0327>`_] مانند برنامه حسابداری. مفسر پایتون برای ارائه نوع ممیز شناور به کامپیوتر از کدگذاری Binary Floating-Point (`استاندارد IEEE 754 <https://en.wikipedia.org/wiki/IEEE_floating_point>`_) استفاده می‌کند. این کدگذاری اعداد در مبنای ده که مورد نظر کاربر هستند را - مانند ``0.1`` - به شکل دقیق ارائه نمی‌دهد؛ به عنوان نمونه عدد  ``0.1`` برابر با عددی نزدیک به ``0.10000000000000001`` در محاسبات کامپیوتر شرکت داده می‌شود؛ هر چند که این عدد بسیار نزدیک به ``0.1`` است ولی به هر حال خود آن نیست!. این موضوع ممکن است در برخی موارد موجب خطا منطقی در برنامه گردد::

    >>> a = 0.1 + 0.1 + 0.1
    >>> a == 0.3
    False
    >>> a
    0.30000000000000004


*در نمونه کد بالا کاربر انتظار دارد که عبارت سطر دوم با ارزش درستی True ارزیابی گردد که این اتفاق نمی‌افتد.*

در پایتون نوع دسیمال  با ایجاد شی از کلاس  ``Decimal`` درون  ماژول ``decimal`` در دسترس قرار گرفته است [`اسناد پایتون  <http://docs.python.org/3.4/library/decimal.html>`__]. به نمونه کد پایین توجه نمایید::

    >>> import decimal

    >>> a = decimal.Decimal('0.1')
    >>> b = decimal.Decimal('0.3')
    
    >>> b == a + a + a
    True

    >>> type(a)
    <class 'decimal.Decimal'>

    >>> a
    Decimal('0.1')

    >>> print(a)
    0.1

به شیوه‌های گوناگونی می‌توان شی دسیمال ایجاد کرد:

.. code-block:: python
    :linenos:

    a = decimal.Decimal(23)                  # Creates Decimal("23")
    b = decimal.Decimal("23.45")             # Creates Decimal("23.45")
    c = decimal.Decimal("2345e-2")           # Creates Decimal("23.45")
    d = decimal.Decimal((1,(2,3,4,5),-2))    # Creates Decimal("-23.45")
    e = decimal.Decimal("infinity")
    f = decimal.Decimal("NaN")

* از آنجا که نوع ممیز شناور دقیق نیست؛ این اعداد را حتما به صورت رشته به ``Decimal`` ارسال نمایید (سطر دوم).
* اعداد را همچنین می‌توان به صورت یک شی تاپل (Tuple) - ساختاری مشابه: (... ,Ο, Ο, Ο) - ارسال کرد (سطر چهارم). شیوه نماد علمی را به یاد بیاورید؛ تاپل مورد نظر باید ساختاری مشابه الگو ``(sign, digits, exponent)`` داشته باشد که در آن sign مثبت بودن (توسط عدد صفر) یا منفی بودن (توسط عدد یک) را مشخص می‌کند، digits خود تاپلی است که عددهای دخیل را بیان می‌کند و exponent نیز بیانگر همان توان است.

میزان دقت (Precision) و عمل گرد کردن (Rounding) اعداد از نوع دسیمال با استفاده از یک شی ``Context`` قابل کنترل است؛ این شی یک سری اطلاعات پیکربندی را در اختیار اشیا دسیمال قرار می‌دهد و برای دسترسی به آن از  تابع ``()getcontext`` درون ماژول ``decimal`` استفاده می‌شود. تابع ``()getcontext`` شی ``Context`` اشیا دسیمال جاری برنامه را برمی‌گرداند. در برنامه‌نویسی چندنخی (Multithreading) هر نخ (thread) شی ``Context`` خاص خود را دارد؛ بنابراین این تابع شی ``Context`` مربوط به نخ فعال را برمی‌گرداند::

    >>> import decimal

    >>> a = decimal.Decimal('3.45623')
    >>> b = decimal.Decimal('0.12')

    >>> a + b
    Decimal('3.57623')

    >>> print(a + b)
    3.57623

    >>> ctx = decimal.getcontext()
    >>> type(ctx)
    <class 'decimal.Context'>

    >>> ctx.prec = 1
    >>> a + b
    Decimal('4')

    >>> ctx.prec = 2
    >>> a + b
    Decimal('3.6')

    >>> ctx.prec = 3
    >>> a + b
    Decimal('3.58')


همانطور که در نمونه کد بالا مشاهده می‌شود دقت محاسبات اعداد دسیمال را می‌توان با استفاده از صفت ``prec`` شی ``Context`` به شکل دلخواه تنظیم نمود؛ مقدار پیش‌فرض این صفت ``28`` است. بدیهی است برای اینکه اعداد در محدوده دقت کوچکتری نسبت به طول خود قرار بگیرند نیاز به گرد شدن دارند؛ برای تنطیم عمل گرد کردن در اعداد دسیمال نیز از صفت ``rounding`` با مقدار پیش‌فرض ``"ROUND_HALF_EVEN"`` استفاده می‌شود::

    >>> a = decimal.Decimal('2.0')
    >>> b = decimal.Decimal('0.52')

    >>> ctx.prec
    28
    >>> ctx.rounding
    'ROUND_HALF_EVEN'

    >>> print(a + b)
    2.52

    >>> ctx.prec = 2

    >>> print(a + b)
    2.5

    >>> ctx.rounding = "ROUND_CEILING"

    >>> print(a + b)
    2.6

صفت ``rounding`` می‌بایست حاوی مقادیر ثابتی به شرح پایین باشد:

* **ROUND_CEILING** - گرد کردن به سمت مثبت بی‌نهایت: یعنی برای اعداد **مثبت** ارقام خارج از محدوده حذف می‌گردند و آخرین رقم باقی مانده یک واحد افزایش می‌یابد مثلا عدد ``2.52`` به ``2.6`` گرد می‌شود. برای اعداد منفی نیز تنها اعداد خارج از محدوده حذف می‌گردند مثلا عدد ``2.19-`` به ``2.1-`` گرد می‌شود.
* **ROUND_FLOOR** - گرد کردن به سمت منفی بی‌نهایت: یعنی برای اعداد **منفی** ارقام خارج از محدوده حذف می‌گردند و آخرین رقم باقی مانده یک واحد افزایش می‌یابد مثلا عدد ``2.52-`` به ``2.6-`` گرد می‌شود. برای اعداد مثبت نیز تنها اعداد خارج از محدوده حذف می‌گردند مثلا عدد ``2.19`` به ``2.1`` گرد می‌شود.
* **ROUND_DOWN** - گرد کردن به سمت صفر: یعنی برای اعداد مثبت و منفی تنها ارقام خارج از محدوده حذف می‌گردند مثلا عدد ``2.58`` به ``2.5`` و عدد ``2.58-`` به ``2.5-`` گرد می‌شود.
* **ROUND_UP** - گرد کردن به دور از صفر: یعنی برای اعداد مثبت و منفی ارقام خارج از محدوده حذف می‌گردند و آخرین رقم باقی مانده یک واحد افزایش می‌یابد مثلا عدد ``2.52`` به ``2.6`` و عدد ``2.52-`` به ``2.6-`` گرد می‌شود.
* **ROUND_HALF_DOWN** - اگر رقم ابتدایی بخش حذف شده بزرگتر از ``5`` باشد به روش ROUND_UP و در غیر این صورت به روش ROUND_DOWN گرد می‌گردد. مثلا عدد ``2.58`` به ``2.6`` و عدد ``2.55`` به ``2.5`` گرد شده و همینطور عدد ``2.58-`` به ``2.6-`` و عدد ``2.55-`` به ``2.5-`` گرد می‌شود.
* **ROUND_HALF_UP** - اگر رقم ابتدایی بخش حذف شده بزرگتر یا برابر ``5`` باشد به روش ROUND_UP و در غیر این صورت به روش ROUND_DOWN گرد می‌گردد. مثلا عدد ``2.55`` به ``2.6`` و عدد ``2.51`` به ``2.5`` گرد شده - همینطور عدد ``2.55-`` به ``2.6-`` و عدد ``2.51-`` به ``2.5-`` گرد می‌کند.
* **ROUND_HALF_EVEN** - همانند ROUND_HALF_DOWN است ولی در مواقعی که رقم ابتدایی بخش حذف شده برابر ``5`` باشد رفتار آن متفاوت می‌شود: در این حالت اگر آخرین رقم باقی مانده زوج باشد به شیوه ROUND_DOWN و اگر فرد باشد به روش ROUND_UP گرد می‌گردد. مثلا عدد ``2.68`` به ``2.7``، ``2.65`` به ``2.6`` و ``2.75`` به ``2.8`` - همینطور عدد ``2.68-`` به ``2.7-``، ``2.65-`` به ``2.6-`` و ``2.75-`` به ``2.8-`` گرد می‌کند.
* **ROUND_05UP** - اگر بر اساس روش ROUND_DOWN آخرین رقم باقی مانده ``0`` یا ``5`` باشد؛ به روش ROUND_UP و در غیر این صورت به همان شیوه ROUND_DOWN گرد می‌کند. مثلا عدد ``2.58`` به ``2.6`` و ``2.48`` به ``2.4`` - همینطور عدد ``2.58-`` به ``2.6-`` و ``2.48-`` به ``2.4-`` گرد می‌شود.

ماژول ``decimal`` یا نوع دسیمال پایتون شامل جزییات و ویژگی‌های بسیار بیشتری است که برای آگاهی از آن‌ها می‌بایست صفحه `اسناد پایتون  <http://docs.python.org/3.4/library/fractions.html>`__ را مطالعه نمایید.

کسر
~~~~~
این نوع برای پشتیبانی اعداد گویا (Rational) در پایتون ارائه شده است و با ایجاد شی از کلاس ``Fraction`` درون ماژول ``fractions`` در دسترس قرار می‌گیرد [`اسناد پایتون  <http://docs.python.org/3.4/library/fractions.html>`__]::

    >>> import fractions
    >>> a = 1
    >>> b = 2
    >>> f = fractions.Fraction(a, b)
    >>> f
    Fraction(1, 2)
    >>> print(f)
    1/2
    >>> type(f)
    <class 'fractions.Fraction'>

علاوه بر روش بالا که به صورت مستقیم صورت و مخرج کسر  - از نوع صحیح - مشخص شده است؛ به روش‌های دیگری نیز می‌توان یک شی کسری ایجاد نمود:

* از یک شی ممیز شناور - بهتر است این نوع به صورت رشته وارد شود::

    >>> print(fractions.Fraction('0.5'))
    1/2
    >>> print(fractions.Fraction('1.1'))
    11/10
    >>> print(fractions.Fraction('1.5'))
    3/2
    >>> print(fractions.Fraction('2.0'))
    2

  ::

      >>> print(fractions.Fraction(0.5))
      Fraction(1, 2)

      >>> print(fractions.Fraction(1.1))
      2476979795053773/2251799813685248
      >>> 2476979795053773 / 2251799813685248
      1.1

      >>> print(fractions.Fraction(1.5))
      3/2

  متد ``()limit_denominator`` می‌تواند یک شی ممیز شناور را با محدود کردن مخرج در یک بیشینه مقدار به صورت تقریبی به یک شی کسر تبدیل نماید::

      >>> fractions.Fraction(1.1).limit_denominator()
      Fraction(11, 10)

  ::

      >>> import math
      >>> math.pi
      3.141592653589793
      >>> pi = math.pi
      >>> fractions.Fraction(pi)
      Fraction(884279719003555, 281474976710656)
      >>> 884279719003555 / 281474976710656
      3.141592653589793

      >>> fractions.Fraction(pi).limit_denominator()
      Fraction(3126535, 995207)
      >>> 3126535 / 995207
      3.1415926535886505

      >>> fractions.Fraction(pi).limit_denominator(8)
      Fraction(22, 7)
      >>> 22 / 7
      3.142857142857143

      >>> fractions.Fraction(pi).limit_denominator(60)
      Fraction(179, 57)
      >>> 179 / 57
      3.1403508771929824







* از یک شی دسیمال::

    >>> print(fractions.Fraction(decimal.Decimal('1.1')))
    11/10

* از یک رشته کسری - صورت و مخرج کسر می‌بایست از نوع صحیح باشند::

    >>> print(fractions.Fraction('3/14'))
    3/14

* از یک شی کسر دیگر::

    >>> f1 = fractions.Fraction(1, 2)
    >>> f2 = fractions.Fraction(3, 5)
    >>> fractions.Fraction(f1)
    Fraction(1, 2)
    >>> fractions.Fraction(f1, f2)
    Fraction(5, 6)

با استفاده از دو صفت ``numerator`` و ``denominator`` می‌توان به ترتیب به صورت و مخرج شی کسر دسترسی یافت::

    >>> f = fractions.Fraction('1.5')
    >>> f.numerator
    3
    >>> f.denominator
    2

از این نوع شی به سادگی می توان در انواع محاسبات ریاضی استفاده کرد؛ برای نمونه به تکه کد پایین توجه نمایید::

    >>> fractions.Fraction(1, 2) + fractions.Fraction(3, 4)
    Fraction(5, 4)

    >>> fractions.Fraction(5, 16) - fractions.Fraction(1, 4)
    Fraction(1, 16)

    >>> fractions.Fraction(3, 5) * fractions.Fraction(1, 2)
    Fraction(3, 10)

    >>> fractions.Fraction(3, 16) / fractions.Fraction(1, 8)
    Fraction(3, 2)

چنانچه یک شی صحیح به شی کسر افزوده شود حاصل یک شی کسر است ولی اگر یک شی ممیز شناور به شی کسر افزوده شود حاصل یک شی از نوع ممیز شناور می‌باشد::

    >>> fractions.Fraction(5, 2) + 3
    Fraction(11, 2)
    >>> fractions.Fraction(5, 2) + 3.0
    5.5

.. rubric:: ب.م.م

ماژول ``fractions`` علاوه بر نوع کسری؛ حاوی تابع ``()gcd`` نیز است. این تابع «بزرگترین مقسوم‌علیه مشترک» (`GCD  <https://en.wikipedia.org/wiki/Greatest_common_divisor>`_) دو عدد را برمی‌گرداند::

    >>> import fractions
    >>> fractions.gcd(54, 24)
    6

بولی
~~~~~~

رشته
------
نوع «رشته» (String) در پایتون با قرار گرفتن دنباله‌ای از کاراکترها درون نماد نقل قول (Quotation) تکی ``' '`` یا دو تایی ``" "`` ایجاد می‌شود؛ به مانند ``"Python Strings"`` یا ``'Python Strings'`` که تفاوتی با یکدیگر ندارند::

    >>> a = "Python Strings"
    >>> a
    'Python Strings'
    >>> print(a)
    Python Strings


.. rubric:: دنباله چیست؟

رشته یک **دنباله** (Sequence) از کاراکترهاست در نتیجه می‌توان هر یک از اعضای این دنباله را با استفاده از اندیس (Index) موقعیت آن دستیابی نمود؛ اندیس اعضا از سمت چپ با عدد صفر شروع و به سمت راست یک واحد یک واحد افزایش می‌یابد. به عنوان نمونه برای شی ``'Python Strings'`` می‌توانیم شمای اندیس‌گذاری را به صورت پایین در نظر بگیریم::

     P y t h o n   S t r i n g s
     - - - - - - - - - - - - - -
     0 1 2 3 4 5 6 7  ...      13

برای دستیابی اعضای یک دنباله با نام ``seq`` از الگو ``[seq[i`` که ``i`` اندیس عضو مورد نظر است؛ استفاده می‌شود::

    >>> a = "Python Strings"
    >>> a[0]
    'P'
    >>> a[7]
    'S'
    >>> a[6]
    ' '

.. rubric:: چند نکته:

* الگو ``[seq[-i`` اعضا دنباله را از سمت راست پیمایش می کند؛ اندیس سمت راست ترین عضو ``1-`` است و به ترتیب به سمت چپ یک واحد یک واحد کاهش می‌یابد.
* الگو ``[seq[i:j`` اعضایی از دنباله را که در بازه‌ای از اندیس ``i`` تا قبل از اندیس ``j`` هستند را دستیابی می‌کند. برای بیان نقاط «از ابتدا» و «تا انتها» می‌توان به ترتیب ``i`` و ``j`` را ذکر نکرد.
* الگو ``[seq[i:j:k`` همانند قبلی است با این تفاوت که ``k`` اندازه گام پیمایش اعضا را تعیین می‌کند.
* با استفاده از تابع ``()len`` می‌توان تعداد اعضای یک دنباله را به دست آورد [`اسناد پایتون  <https://docs.python.org/3.4/library/functions.html#len>`__].

::

    >>> a = "Python Strings"

    >>> len(a)
    14

    >>> a[-2]
    'g'

    >>> a[2:4]
    'th'
    >>> a[7:]
    'Strings'
    >>> a[:6]
    'Python'
    >>> a[:-1]
    'Python String'

    >>> a[2:12:3]
    'tntn'
    >>> a[:6:2]
    'Pto'
    >>> a[7::4]
    'Sn'

    >>> a[-1]
    's'
    >>> a[len(a)-1]
    's'



باید توجه داشت که یک شی رشته جزو انواع immutable پایتون است و مقدار (یا اعضا دنباله) آن را نمی‌توان تغییر داد؛ برای مثال نمی‌توان شی ``'Python Strings'`` به ``'Python-Strings'`` تغییر داد - برای این کار تنها می‌بایست یک شی جدید ایجاد کرد::

    >>> a = "Python Strings"
    >>> a[6] = "-"
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'str' object does not support item assignment


.. rubric:: عملگرها در رشته

با رشته‌ها نیز می‌توان از عملگرهای ``+`` (برای پیوند رشته‌ها) و ``*`` (برای تکرار رشته‌ها) بهره برد:: 

    >>> a = "Python" + " " + "Strings"
    >>> a
    'Python Strings'

    >>> "-+-" * 5
    '-+--+--+--+--+-'

کمی جلوتر خواهید دید که از عملگر ``%`` برای قالب‌بندی رشته‌ها استفاده می‌گردد.

.. rubric:: کاراکترهای Escape

به صورت پیش‌فرض تعدادی کاراکتر خاص تعریف شده است که می‌توان آن‌ها را درون رشته‌ها بکار برد. تمام  این کاراکترها با یک ``\`` آغاز می‌شوند به همین دلیل گاهی نیز به نام Backslash Characters خوانده می‌شوند. در واقع این کاراکترها امکانی برای درج برخی دیگر از کاراکترها هستند که نمی‌توان آن‌ها را به سادگی توسط صفحه‌کلید وارد کرد. برای نمونه یکی از کاراکترهای Escape رایج ``n\`` است که بیانگر کاراکتری با کد اسکی 10 (LF) به نام newline می‌باشد؛ ``n\`` در هر جایی از رشته (یا متن) که درج گردد در هنگام چاپ سطر جاری را پایان می‌دهد و ادامه رشته (یا متن) از سطر جدید آغاز می‌‌شود [`اسناد پایتون <http://docs.python.org/2/reference/lexical_analysis.html#string-literals>`__]::

    >>> a = "Python\nProgramming\nLanguage"
    >>> a
    'Python\nProgramming\nLanguage'
    >>> print(a)
    Python
    Programming
    Language
    >>> 

برخی از این کاراکترها به شرح پایین است:

* ``n\`` - پایان سطر جاری و رفتن به سطر جدید
* ``t\`` - برابر کد اسکی 9 (TAB): درج هشت فاصله (کلید Space)
* ``uxxxx\`` - درج یک کاراکتر یونیکد 16 بیتی با استفاده از مقدار هگزادسیمال (مبنای شانزده) آن : ``"u067E\"``
* ``Uxxxxxxxx\`` - درج یک کاراکتر یونیکد 32 بیتی با استفاده از مقدار هگزادسیمال (مبنای شانزده) آن : ``"U0001D11E\"``
* ``ooo\`` - درج یک کاراکتر با استفاده از مقدار اُکتال (مبنای هشت) آن : ``"123\"``
* ``xhh\`` - درج یک کاراکتر با استفاده از مقدار هگزادسیمال (مبنای شانزده) آن : ``"x53\"``
* ``'\`` - درج یک کاراکتر ``'``
* ``"\`` - درج یک کاراکتر ``"``
* ``\\`` - درج یک کاراکتر ``\``

این ویژگی رشته‌ها گاهی موجب مشکل می‌شود؛ فرض کنید می‌خواهیم آدرس فایلی از سیستم عامل ویندوز  را چاپ نماییم::

    >>> fpath = "C:\new\text\sample.txt"

    >>> print(fpath)
    C:
    ew	ext\sample.txt

برای حل مشکل نمونه کد بالا می‌توان هر جا که نیاز به ``\`` است از ``\\`` استفاده کرد: ``"C:\\new\\text\\sample.txt"``. ولی راهکار جامع‌تر ایجاد «**رشته‌های خام**» (Raw Strings) است؛ در این نوع رشته‌، کاراکترهای Escape بی‌اثر هستند. رشته خام با افزوده شدن یک حرف ``r`` یا ``R`` به ابتدای یک رشته معمولی ایجاد می‌گردد::

    >>> fpath = r"C:\new\text\sample.txt"
    >>> print(fpath)
    C:\new\text\sample.txt


.. rubric:: قالب‌بندی رشته‌ (String Formatting)

قالب‌بندی امکانی برای جایگزین کردن یک یا چند مقدار (به بیان بهتر: شی) درون یک رشته است که به دو شکل در پایتون پیاده‌سازی می‌گردد [`اسناد پایتون <https://docs.python.org/2/library/string.html#string-formatting>`__]:

۱. قالب سنتی - با الگو  ``(s..." % (values%..."``

  از دو بخش تشکیل شده است؛ بخش سمت چپ عملگر ``%``، رشته‌ای را مشخص می‌کند که شامل یک یا چند کد جایگذاری شی می‌باشد - کدهای جایگذاری همگی با یک کاراکتر ``%`` شروع می‌شوند؛ مانند: ``s%`` - و در سمت آن شی‌هایی برای جایگزینی در رشته، داخل پرانتز قرار دارد؛ این اشیا به ترتیب از سمت چپ درون رشته جایگذاری می‌گردند::

      >>> "Python is %s to learn if you know %s to start!" % ("easy", "where")
      'Python is easy to learn if you know where to start!'

  برخی از کدهای جایگذاری به شرح پایین است:

  * ``s%`` - جایگزینی در قالب یک رشته به شکل خروجی تابع ``()str``
  * ``r%`` - جایگزینی در قالب یک رشته به شکل خروجی تابع ``()repr``
  * ``c%`` - جایگزینی در قالب یک کاراکتر: یک عدد صحیح که نشانگر کد کاراکتر می‌باشد را به کاراکتر یونیکد تبدیل کرده و درون رشته قرار می دهد.

  ::

      >>> "%r is a %s language." % ("Python", "programming")
      "'Python' is a programming language."

      >>> er = 1427
      >>> "Error %s!" % (er)
      'Error 1427!'

      >>> "A, B, C, ... Y, %c" % (90)
      'A, B, C, ... Y, Z'

  * ``d%`` یا ``i%`` - جایگزینی در قالب یک عدد صحیح در مبنا ده
  * ``o%`` - جایگزینی در قالب یک عدد صحیح در مبنا هشت
  * ``x%`` - جایگزینی در قالب یک عدد صحیح در مبنا شانزده با حروف کوچک
  * ``X%`` - جایگزینی در قالب یک عدد صحیح در مبنا شانزده با حروف بزرگ

  ::

      >>> "4 + 4 = %d" % (2*4)
      '4 + 4 = 8'

      >>> "%d" % (0b0110)
      '6'

      >>> "%d" % (12.6)
      '12'

      >>> "int('%o', 8) = %d" % (0o156, 0o156)
      "int('156', 8) = 110"

      >>> "15 = %X in HEX" % (15)
      '15 = F in HEX'




  * ``f%`` - جایگزینی در قالب یک عدد ممیز شناور (دقت پیش‌فرض: ۶) در مبنا ده
  * ``F%`` - همانند ``f%`` ؛ با این تفاوت که ``nan`` و ``inf`` را به شکل ``NAN`` و ``INF`` درج می‌کند.
  * ``e%`` - جایگزینی در قالب یک عدد ممیز شناور به شکل نماد علمی با حرف کوچک
  * ``E%`` - جایگزینی در قالب یک عدد ممیز شناور به شکل نماد علمی با حرف بزرگ

  ::

      >>> "%f" % (12.526)
      '12.526000'

      >>> "%f" % (122e-3)
      '0.122000'

      >>> "%E" % (12.526)
      '1.252600E+01'

  همچنین این الگو را می‌توان با استفاده از یک شی دیکشنری - این نوع در بخش دوم این درس بررسی می‌گردد - پیاده‌سازی نمود. در این شیوه اشیا با استفاده از کلید جایگذاری می‌گردند و دیگر ترتیب آن‌ها اهمیتی ندارد. به نمونه کد پایین توجه نمایید::

      >>> '%(qty)d more %(product)s' % {'product': 'book', 'qty': 1}
      '1 more book'  


      >>> reply = """
      ... Greetings...
      ... Hello %(name)s!
      ... Your age is %(age)s
      ... """
      >>> values = {'name': 'Bob', 'age': 40}
      >>> print(reply % values)
      
      Greetings...
      Hello Bob!
      Your age is 40
      
      >>>

  در اصل می‌توان برای این قالب، ساختاری مانند پایین را در نظر گرفت::

      %[(keyname)][flags][width][.precision]typecode


  * در هر استفاده وجود هر یک از []ها اختیاری است یا بستگی به شیوه استفاده دارد.
  * (keyname) - درج کلید داخل پرانتز - در مواقع استفاده از شی دیکشنری آورده می‌شود.
  * flags - می‌تواند یکی از سه نماد ``+``، ``−`` و ``0`` باشد. ``+`` موجب درج علامت عدد می‌شود، ``−`` موجب چپ‌چین شدن مقدار می‌گردد (حالت پیش‌فرض راست‌چین است) و ``0`` تعیین می‌کند که فضای خالی اضافی با صفر پر گردد (در حالت پیش‌فرض Space گذاشته می‌شود).
  * width - اندازه عرض را تعیین می‌کند؛ در مواردی که عرض تعیین شده بیشتر از عرض واقعی مقدار باشد، فضای اضافی را می‌توان با صفر یا فضای خالی (Space) پر کرد و البته زمانی که کمتر تعیین گردد، این گزینه نادیده گرفته می‌شود.
  * precision. - در مورد اعداد ممیز شناور، تعداد اعداد بعد از ممیز را تعیین می‌کند. در مواردی که عرض تعیین شده کمتر از عرض واقعی مقدار باشد، بخش اضافی حذف می‌گردد.
  * typecode - بیانگر همان حرف تعیین کننده نوع کد جایگذاری می‌باشد.
  * به جای width و precision. می توان از ``*`` استفاده کرد که در این صورت  

۲. قالب جدید، توسط فراخوانی متد ``()format`` - با الگو ``(format(values."...{}..."``

  در این قالب که در نسخه‌های 2.6، 2.7 و 3x پایتون در دسترس است؛ اشیا آرگومان‌های یک متد مشخص هستند و با استفاده اندیس موقعیت‌ یا نام آن‌ها داخل ``{}`` در رشته جایگذاری می‌گردند::

      >>> '{0} {1} {2}'.format("Python", "Programming", "Language")
      'Python Programming Language'

  ::

      >>> reply = """
      ... Greetings...
      ... Hello {name}!
      ... Your age is {age}
      ... """
      >>> print(reply.format(age=40, name='Bob'))

      Greetings...
      Hello Bob!
      Your age is 40

      >>>

  ::

      >>> "{0} version {v}".format("Python", v="3.4")
      'Python version 3.4'

  .. caution::
      همانطور که در درس تابع‌ خواهیم آموخت؛ بدون نیاز به رعایت ترتیب می‌توان آرگومان‌ها را با انتساب مقدار مورد نظر به آن‌ها ارسال نمود.

.. rubric:: تبدیل کد به کاراکتر و برعکس

برای این منظور می‌توان از دو تابع ``()ord`` (تبدیل کد به کاراکتر) و ``()chr`` (تبدیل کاراکتر به کد) استفاده کرد. تابع ``()ord`` یک رشته تک کاراکتری را گرفته و یک عدد (در مبنا ده) که بیانگر کد کاراکتر مورد نظر می‌باشد را برمی‌گرداند. تابع  ``()chr`` نیز کد کاراکتری (که می‌بایست عددی در مبنا ده باشد) را گرفته و کاراکتر مربوط به آن را برمی‌گرداند::

    >>> Python 3.x

    >>> ord("A")
    65
    >>> chr(65)
    'A'
    
    >>> int("067E", 16)
    1662
    >>> chr(1662)        # unicode
    'پ'
    >>> ord(_)           # _ is result of the last executed statement  = 'پ'
    1662

    >>> ord("\U0001D11E")
    119070
    >>> chr(_)
    '𝄞'


از آنجا که **نسخه‌های 2x** پایتون به صورت پیش‌فرض از کدگذاری تحت استاندارد یونیکد پشتیبانی نمی‌کنند؛ برای گرفتن کاراکتر یونیکد (کاراکترهای خارج از محدوده اَسکی) از کد آن، می‌بایست از تابع جداگانه‌ای با نام ``()unichr`` استفاده نماییم::

    >>> Python 2.x

    >>> ord("a")
    97
    >>> chr(97)
    'a'

    >>> unichr(1662)
    u'\u067e'
    >>> print _
    پ

    >>> ord(u"\U0001D11E")
    119070
    >>> unichr(_)
    u'\U0001d11e'
    >>> print _
    𝄞



.. rubric:: چگونگی ارايه نوع رشته از موارد اختلاف اساسی در نسخه‌های 2x و 3x پایتون است. 

در **نسخه‌های 2x** یک نوع جامع ``str`` که محدود به کدگذاری ASCII است؛ هر دو قالب رشته‌های معمولی و داده‌های باینری (متن‌های کدگذاری شده، فایل‌های مدیا و پیام‌های شبکه) را  در بر می‌گیرد - رشته باینری با یک حرف b در آغاز آن‌ مشخص می‌گردد. در این سری از نسخه‌ها نوع دیگری نیز با نام ``unicode`` وجود دارد که رشته‌های خارج از محدوده کدگذاری ASCII را در بر می‌گیرد؛ برای ایجاد این نوع اشیا می‌بایست رشته مورد نظر با یک حرف ``u`` آغاز گردد::

    >>> # python 2.x

    >>> a = "python"
    >>> type(a)
    <type 'str'>

    >>> a = b"python"
    >>> type(a)
    <type 'str'>

    >>> a = u"python"
    >>> type(a)
    <type 'unicode'>

ولی در **نسخه‌های 3x** رشته توسط سه نوع ارایه می‌گردد. اکنون کدگذاری پیش‌فرض کاراکترها در پایتون از ASCII بسیار گسترده‌تر شده است و از استاندارد یونیکد پشتیبانی می‌کند بنابراین نوع ``str`` به تنهایی می‌تواند تقریبا تمامی کاراکترها را شامل شود و دیگر نیازی به نوع جداگانه و استفاده از حرف ``u`` برای مشخص کردن رشته‌های یونیکد نیست. تغییر دیگری نیز رخ داده است؛ در این نسخه‌ها نوع داده باینری از رشته‌های معمولی جدا شده است و توسط نوع جدیدی با نام ``bytes`` ارایه می‌گردد. 





|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <http://coderz.ir/python-tutorial-object-types/>`_


