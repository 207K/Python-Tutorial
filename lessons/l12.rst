.. role:: emoji-size

.. meta::
   :description: کتاب آنلاین و آزاد آموزش زبان برنامه‌نویسی پایتون به فارسی - درس دوازدهم تابع
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, انواع شی, انواع داده, پایتون


درس ۱۲: تابع
============








:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----



مقدمه
------

**تابع (Function)** به بلاکی از دستورات گفته می‌شود که برای به اجرا درآمدن نیازمند فراخوانی هستند و این فراخوانی می‌تواند بیش از یک بار در برنامه انجام گیرد. تابع می‌تواند به هنگام فراخوانی مقادیری را دریافت کند و در صورت لزوم مقداری نیز به عنوان نتیجه برگرداند.

تابع جایگزینی برای بخش‌های تکراری برنامه است که با یک بار نوشتن و چندین بار فراخوانی و اجرای آن می‌توان از پیچیدگی برنامه جلوگیری و تغییر در آن را آسان نمود. استفاده از توابع باعث بالابردن قابلیت استفاده مجدد از کدها می‌شود و افزونگی را نیز کاهش می‌دهد. توابع ابزاری برای خرد کردن منطق برنامه به واحدهای اجرایی کوچکتر برای تسهیل ساخت برنامه‌های بزرگ است.

سینتکس تابع در زبان برنامه‌نویسی پایتون همانند هر دستور مرکب دیگری شامل یک سرآیند و یک بدنه است - درس ششم. بخش سرآیند شامل کلمه کلیدی ``def``، یک نام به دلخواه کاربر و پرانتز‌ می‌باشد که این پرانتز‌ محل قرار گرفتن پارامترهای تابع را نمایش می‌دهد. هر تابع می‌تواند هیچ، یک یا چند پارامتر بپذیرد::

    def function_name(param1, param2,... paramN):
        statements

همانطور که بارها گفته شد، هر چیزی در پایتون شی است، هنگامی که اجرای برنامه به کلمه کلیدی ``def`` می‌رسد، ابتدا یک شی تابع ایجاد و سپس از نام تابع (در اینجا: function_name) به آن ارجاع داده می‌شود::

    >>> def func_name():
    ...     pass
    ... 
    >>>
    >>> type(func_name)
    <class 'function'>

.. tip:: 
    پیشنهاد `PEP 8 <http://www.python.org/dev/peps/pep-0008>`__: نام تابع از حروف کوچک تشکیل شود که کلمه‌های آن با استفاده از خط زیرین (Underscores) از یکدیگر جدا شده باشند. مانند: my_function . حالت ``mixedCase`` مانند: myFunction نیز صحیح می‌باشد به شرط آنکه در سراسر کدها نام توابع با همین الگو نوشته شود.

بدنه تا زمانی که تابع فراخوانی نگردد، اجرا نمی‌شود. برای فراخوانی تابع از نام تابع + پرانتز استفاده می‌شود و در صورتی که در تعریف تابع پارامترهایی قرار داده شده باشد، می‌بایست هنگام فراخوانی آرگومان‌های متناسب با این پارامترها نیز ارسال گردند::

    function_name(arg1, arg2,... argN)


.. caution:: 
    در بحث توابع، به متغیرهایی که در سرآیند تابع تعریف می‌شوند پارامتر (Parameter) و به داده‌هایی که هنگام فراخوانی تابع ارسال می‌گردد آرگومان (Argument) گفته می‌شود. به ازای هر آرگومان ارسالی می‌بایست یک پارامتر در تابع جهت دریافت آن تعریف شده باشد. هیچ الزامی به هم نام بودن آرگومان‌ها و پارامترهای نظیر وجود ندارد ولی وجود هم نامی باعث خوانایی بیشتر کد می‌شود.



بدنه تابع می تواند حاوی کلمه کلیدی ``return`` نیز باشد. در واقع ``return`` دستوری است که در هر جایی از بدنه آورده شود، اجرای تابع در آن نقطه متوقف و مقداری (البته در زبان پایتون درست این است که گفته شود: شی‌ایی) را به عنوان نتیجه به محل فراخوانی تابع بازمی‌گرداند::

    def function_name(param1, param2,... paramN):
        ...
        return value

در نمونه کد بالا value مقداری است که توسط ``return`` به محل فراخوانی بازگردانده می‌شود. value می‌تواند صراحتا یک مقدار نباشد بلکه یک عبارت مانند : ``param1**2`` یا ``param1 > 3`` و... باشد که در این صورت ابتدا حاصل عبارت ارزیابی و سپس بازگردانده می‌شود. چنانچه value ذکر نگردد، ``None`` بازگردانده می‌شود::

    >>> def my_pow(x, y):
    ...     return x**y
    ... 
    >>> 
    >>> a = 2
    >>> b = 3
    >>> 
    >>> my_pow(a, b)
    8
    >>>

در زبان برنامه نویسی پایتون تابع یک موجودیت **”first-class“** است که یعنی تابع را می‌توان مانند دیگر اشیا به صورت پویا ایجاد یا نابود کرد، به صورت آرگومان به توابع دیگر ارسال نمود، به عنوان نتیجه توسط ``return`` بازگرداند و... در نتیجه می‌توان یک تابع را درون بدنه دستورات کنترلی (``while`` ،``if`` و...) یا درون بدنه تابعی دیگر تعریف نمود::

   >>> def outer(num1):
   ...     def inner_increment(num1):  # hidden from outer code
   ...         return num1 + 1
   ...     num2 = inner_increment(num1)
   ...     print(num1, num2)
   ... 
   >>> 
   >>> outer(1)
   1 2


خیلی خوب است که با استفاده از ”Docstring“ در توابع به مستندسازی و خوانایی بهتر برنامه کمک کنیم - درس ششم::


    def function_with_docstring(param1, param2):
        """Example function with types documented in the docstring.

        Args:
            param1 (int): The first parameter.
            param2 (str): The second parameter.

        Returns:
            bool: The return value. True for success, False otherwise.
        """
    

فضاهای نام و حوزه
------------------

در هر برنامه پایتون تعداد زیادی نام وجود دارد که برای نمونه می‌توان به: متغیرها، نام توابع، نام کلاس‌ها و... اشاره کرد. بدیهی است که برای شناسایی اشیا لازم است نام‌ها منحصر به فرد باشند، رعایت چنین امری در یک برنامه حتی کوچک کار سختی است. در زبان پایتون برای دسته‌بندی و جلوگیری از تداخل نام‌ها، ساختاری با عنوان «**فضاهای نام**» (**Namespaces**) در نظر گرفته شده است. هر فضا نام بخشی از نام‌های درون برنامه را دربر‌می‌گیرد. به صورت کلی فضاهای نام پایتون در سه سطح تو در توی «محلی» (Local)، «سراسری» (Global) و Built-in به تصویر کشیده می‌شوند:

.. image:: /_static/nested-namespaces-python.jpg
    :align: center

هر ماژول پایتون یک فضانام سراسری برای خود تشکیل می‌دهد که نسبت به فضا نام دیگر ماژول‌ها ایزوله است. فضانام تمام ماژول‌ها درون فضانام بزرگتری ایجاد می‌گردند که به عنوان فضانام Built-in شناخته می‌شود و نام تمامی توابع آماده مانند ``()open`` که پیش از این استفاده می‌کردیم در این فضا قرار گرفته است. ساختار تو در توی سطوح فضا نام باعث می‌شود که بدون نیاز به import ماژول خاصی در هر جای برنامه به توابع آماده (Built-in) دسترسی داشته باشیم.

هر ماژول می‌تواند شامل تعدادی تابع و کلاس باشد. با فراخوانی هر تابع یک فضانام محلی برای آن تابع، درون فضانام ماژول مربوطه ایجاد می‌گردد و با پایان اجرای تابع نیز از بین می‌رود، در مورد کلاس‌ها هم اتفاق مشابهی رخ می‌دهد. بر همین اساس می‌توانیم درون تابع متغیرهایی متفاوت ولی هم نام با متغیرهای خارج از تابع در ماژول **ایجاد** نماییم چرا که آن‌ها در دو فضانام متفاوت قرار دارند و از طرفی به دلیل داخل بودن فضا نام تابع درون فضا نام ماژول خود، می‌توان به نام‌های خارج از تابع نیز دسترسی داشت.

گفتیم فضا نام ماژول‌ها نسبت به یکدیگر ایزوله هستند. بنابراین برای دسترسی به نام‌های درون ماژول‌های دیگر، ابتدا می‌بایست آن‌ ماژول‌ها را import نماییم که در این صورت با استفاده از نام ماژول - به شکل یک پیشوند - قابل دستیابی هستند. برای نمونه دستیابی نام ``getcwd`` که به یک تابع ارجاع دارد از فضانام ماژول ``os``، در نمونه کد پایین نمایش داده شده است::

    >>> import os

    >>> os.getcwd()
    '/home/saeid'

اما استفاده از نام‌های یک ماژول درون خودش چگونه است؟ جایی که فضا‌های نام دیگری همچون توابع نیز وجود دارند ولی هیچ پیشوندی مانند نام ماژول وجود ندارد که بتوان نام‌های درون این فضاهای متفاوت را از یکدیگر تمیز داد. برای اینکه بدانیم هر نام ماژول در هر نقطه‌ایی از همان ماژول چگونه مورد دستیابی قرار می‌گیرد با مفهوم دیگری به نام «**حوزه**» (**Scope**) آشنا می‌شویم. به صورت کلی حوزه به نواحی‌ایی از برنامه گفته می‌شود که می‌توان یک نام را بدون استفاده از هیچ پیشوندی و البته بدون تداخل با نام‌های دیگر به کار برد. بحث حوزه صرفا در داخل هر ماژول مطرح است.

*قوانین حوزه:*

* بدنه ماژول - منظور نواحی‌ایی که خارج از بدنه توابع و کلاس‌ها قرار دارد - **حوزه سراسری** (**Global Scope**) است. توجه داشته باشید که واژه «سراسری» در بحث حوزه (یا فضانام) تنها به سراسر کدهای داخل هر ماژول اشاره دارد و نه سراسر برنامه. به صورت کلی هر جایی از زبان پایتون که واژه سراسری (Global) را شنیدید (یا خواندید) به یاد ماژول بیافتید::

    # This is a global variable
    a = 0

    if a == 0:
        # This is still a global variable
        b = 1

  *در نمونه کد بالا، حوزه تعریف هر دو متغیر a و b از نوع سراسری است. بدنه دستورات کنترلی فاقد یک فضانام جداگانه است و تعریف متغیر در این نواحی از برنامه  درون حوزه سراسری قرار می‌گیرد.*

  | 


* بدنه هر تابع یک **حوزه محلی** (**Local Scope**) است و به صورت پیش‌فرض تمام متغیرهایی که درون توابع ایجاد می‌گردند درون حوزه محلی قرار گرفته‌اند مگر اینکه با استفاده از کلمه‌های کلیدی ``global`` یا ``nonlocal`` مشخص شده باشند. چنانچه بخواهیم درون تابع انتسابی به یکی از نام‌های موجود در حوزه سراسری انجام دهیم، می‌بایست از دستور ``global`` استفاده کنیم. به نمونه کدهای پایین توجه نمایید::

    
    def my_function(c):
        # this is a local variable
        d = 3


  ::

      >>> a = 0
      >>> 
      >>> def my_function():
      ...    a = 3
      ...    print(a)
      ... 
      >>> 
      >>> a
      0
      >>> my_function()
      3
      >>> a
      0
      >>> 

  ::

     >>> a = 0
     >>> 
     >>> def my_function():
     ...     global a
     ...     a = 3
     ...     print(a)
     ... 
     >>> 
     >>> a
     0
     >>> my_function()
     3
     >>> a
     3
     >>> 

  در توابع تو در تو نیز فرقی ندارد، هر تابع که فراخوانی می‌شود فضانامی مجزا برای آن ایجاد می‌شود و حوزه محلی خود را خواهد داشت. دستور ``nonlocal`` در پایتون ۳ ارائه شده است و در توابع تو در تو کاربرد دارد. هنگامی که بخواهیم داخل بدنه تابع درونی انتسابی به نامی تعریف شده در یکی از توابع بیرونی آن انجام دهیم، می‌بایست از این دستور برای مشخص کردن نام مورد نظر استفاده کنیم::

    >>> def outer():
    ...     x = 1
    ...     def inner():
    ...         x = 2
    ...         print("inner:", x)
    ...     inner()
    ...     print("outer:", x)
    ... 
    >>>
    >>> outer()
    inner: 2
    outer: 1
    >>>

  ::

      >>> def outer():
      ...     x = 1
      ...     def inner():
      ...         nonlocal x
      ...         x = 2
      ...         print("inner:", x)
      ...     inner()
      ...     print("outer:", x)
      ... 
      >>>
      >>> outer()
      inner: 2
      outer: 2
      >>>

* وقتی از متغیری استفاده می‌کنیم، مفسر پایتون ابتدا می‌بایست حوزه و فضانام آن را تشخیص دهد تا بتواند شی‌ایی که این متغیر به آن ارجاع دارد را پیدا کند. فرض کنیم متغیری درون عبارتی در بدنه یک تابع به کار رفته باشد در این صورت مفسر ابتدا حوزه محلی که متغیر در آن وجود دارد را برای یافتن تعریف متغیر جستجو می‌کند و چنانچه نیابد به سراغ حوزه محلی تابع بیرونی آن - در صورت وجود - می‌رود و همینطور ادامه می‌دهد که در نهایت حوزه سراسری ماژول و پس از آن نیز Built-in را بررسی می‌کند؛ اگر هم به نتیجه‌ایی نرسد یک استثنا ``NameError`` رخ می‌دهد::

    >>> x = 0
    >>> 
    >>> def outer():
    ...     x = 1
    ...     def inner():
    ...         print(x)
    ...     inner()
    ... 
    >>> outer()
    1

  ::

      >>> x = 0
      >>> 
      >>> def outer():
      ...     def inner():
      ...         print(x)
      ...     inner()
      ... 
      >>> outer()
      0


  ::

      >>> x = 0
      >>> 
      >>> def outer():
      ...     def inner():
      ...         print(z)
      ...     inner()
      ... 
      >>> outer()
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        File "<stdin>", line 4, in outer
        File "<stdin>", line 3, in inner
      NameError: name 'z' is not defined
      >>> 



ارسال آرگومان
--------------







|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <http://coderz.ir/python-tutorial-function/>`_


