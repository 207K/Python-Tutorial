.. role:: emoji-size

.. meta::
   :description: کتاب آموزش زبان برنامه نویسی پایتون به فارسی، آموزش شی گرایی در پایتون، تعریف کلاس در پایتون، ایجاد شی در پایتون، OOP در پایتون
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, تابع, کتابخانه, پایتون, شی گرایی در پایتون


درس ۱۷: شی گرایی (OOP) در پایتون: تعریف کلاس و ایجاد شی
============================================================================



پیش‌تر مفهوم شی‌گرایی شرح داده شده است (درس پنجم). در این درس می‌خواهیم به بررسی چگونگی پیاده‌سازی این مفهوم در زبان برنامه نویسی پایتون بپردازیم. هنگام نگارش این درس فرض بر این بوده است که خوانندگان دروس پیش، بخصوص درس پنجم و دروس مربوط به توابع را مطالعه کرده‌اند.

این درس بر ارائه تعاریف مربوط به کلاس (Class) و شی (Object) از مفاهیم شی‌گرایی حاکم در زبان برنامه‌نویسی پایتون تمرکز دارد و مفاهیم باقی مانده در دروس آتی ارائه خواهند شد.

توجه داشته باشید، هم اکنون پشتیبانی نسخه 2x پایتون به پایان رسیده است. بنابراین برخلاف دروس پیشین و به منظور جلوگیری از پیچیدگی‌های غیر ضروری، تمام مطالب این درس بر مبنای پایتون 3x ارائه می‌شود.



:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----

برنامه‌نویسی شی گرا (Object-Oriented Programming)
----------------------------------------------------------------------------------------------------

همان‌طور که پیش‌تر نیز گفته شده است، پایتون یک زبان برنامه‌نویسی چند الگویی (multi-paradigm) است و از الگوهای مختلفی از جمله شی گرایی پشتیبانی می‌کند. شی گرایی یک الگوی برنامه‌نویسی یا روشی برای طراحی کدهای برنامه است. 

در این شیوه، کدهای برنامه در قالب موجودیت‌های کوچکی به نام **کلاس (Class)** به وجود می‌آیند. کلاس‌ها چیزی نیستند جز ابزاری که توسط آن می‌توان داده‌ها و عملیات مرتبط با یکدیگر را در یک دسته و جدا از سایر بخش‌های کد قرار داد. با کمک کلاس‌ها رفتار و عملکرد هر تکه از کد مشخص است و با سایر بخش‌های کد تداخل پیدا نمی‌کند. ایجاد یک کلاس به معنی ایجاد یک **نوع (Type)** جدید در برنامه می‌باشد که می‌توان چندین **شی (Object)** یا **نمونه (Instance)**  از آن نوع ایجاد کرد. یک برنامه شی‌گرا حاصل ارتباط و تعامل اشیا مختلف ایجاد شده در آن است.

مفاهیم زیادی از پایتون تا پیش از این درس مطرح شده است، باید بدانیم که تمام آن‌ها از پیاده‌سازی شی گرا پیروی می‌کردند. هر چیزی در پایتون یک شی است. انواع داده مانند اعداد، رشته، لیست یا دیکشنری همگی شی بودند - نمونه‌هایی که از کلاس‌های مربوط به خود ایجاد شده‌اند. حتی تعریف تابع نیز به معنی ایجاد یک شی از کلاس متناطر آن بوده است. اما حالا می‌خواهیم نوع یا کلاس‌های مورد نظر خودمان را در برنامه ایجاد و اشیایی از این کلاس‌ها نمونه سازی کنیم. در ادامه به شرح این روند خواهیم پرداخت.


تعریف کلاس (Class)
--------------------------------------------------------

در پایتون برای تعریف کلاس از کلمه کلیدی ``class`` استفاده می‌گردد؛ همانند الگو پایین::

    class ClassName:
        <statement-1>
        .
        .
        .
        <statement-N>

کلمه کلیدی تعریف کلاس - ``class`` - یک دستور اجراپذیر (Executable Statement) است، همانند دستور ``def`` برای توابع. یک کلاس پیش از اجرای دستور خود هیچ تاثیری در برنامه ندارد. این شرایط سبب می‌شود که حتی بتوان یک کلاس را در میان بدنه دستور شرط (``if``) یا درون بدنه یک تابع تعریف کرد.

بعد از کلمه کلیدی ``class`` نام کلاس (به دلخواه کاربر) نوشته می‌شود. سطر نخست تعریف مانند تمام دستورات مرکب (Compound) که به صورت معمول در چند سطر نوشته می‌شوند و سرآیند دارند، به کاراکتر ``:`` ختم می‌شود. از سطر دوم با رعایت یکنواخت تورفتگی دستورات بدنه کلاس نوشته می‌شوند::
    
    >>> class MyClassName:
    ...     pass
    ... 
    >>> 
    
    >>> type(MyClassName)
    <class 'type'>


.. tip:: 
    پیشنهاد `PEP 8 <http://www.python.org/dev/peps/pep-0008>`__: برای نوشتن نام کلاس از شیوه CapitalizedWords استفاده شود.


.. tip:: 
  کلاس‌ها نیز همانند توابع حوزه (Scope) خود را دارند - درس دوازدهم. با  تعریف هر کلاس یک حوزه محلی جدید در برنامه پایتونی تعریف می‌گردد.

.. tip:: 
  یک کلاس، تعریف کننده صفات (ویژگی‌ها) - که به عنوان Attribute شناخته می‌شوند - و رفتار‌های (عملیات) - که به عنوان Method شناخته می‌شوند - اشیایی است که از آن ایجاد خواهد شد. در واقع نام کلاس معرف نوع (Type) اشیای خود است.


  به بیانی ساده‌تر، هر کلاس می‌تواند شامل تعدادی تابع  و متغیر در داخل بدنه خود باشد. که به متغیرها: Attribute و به توابع: Method گفته می‌شود. هر یک از این Attributeها و Methodها انواعی دارند که در ادامه شرح داده خواهد شد.

نمونه‌سازی (Instantiation)
--------------------------------------------------------

به عملیات ایجاد یک شی از کلاس، **نمونه‌سازی (Instantiation)** گفته می‌شود. کلاس چیزی جز تکه کدی نوشته شده نیست و جایی در حافظه ندارد، این اشیا ایجاد شده از کلاس هستند که در حافظه (Memory) قرار می‌گیرند. نمونه‌سازی از یک کلاس در زبان پایتون به صورت زیر انجام می‌شود::

    >>> class Sample():
    ...     pass
    ... 
    >>> 

    >>> sample_object = Sample()  # Instantiation

    >>> type(sample_object)
    <class '__main__.Sample'>

در زبان برنامه‌نویسی پایتون با فراخوانی نام کلاس - همچون فراخوانی یک تابع - یک شی از آن کلاس ایجاد می‌گرد. 

از هر کلاس می‌توان بی‌نهایت نمونه‌سازی داشت. هر شی از یک کلاس، حوزه (Scope) مخصوص به خود را دارد که جدا از دیگر اشیا آن کلاس خواهد بود. بنابراین اشیا هر کلاس کاملا مستقل و ایزوله (isolated) از یکدیگر هستند. 


سازنده (Constructor)
~~~~~~~~~~~~~~~~~~~~~~~~~

در مبحث شی‌گرایی، هنگام ساخت یک شی (ایجاد یک نمونه جدید)، به صورت خودکار یک متد از داخل کلاس مورد نظر فراخوانی می‌شود. به این متد، **سازنده (Constructor)** گفته می‌شود. فراخوانی خودکار این متد به برنامه‌نویس این امکان را می‌دهد که در صورت تمایل بتواند چگونگی ایجاد شی جدید  را مدیریت یا در همان هنگام ساخت، شخصی‌سازی نماید. 

از طرفی هر کلاس در زبان برنامه‌نویسی پایتون شامل یک سری متد خاص می‌باشد که نام تمام آن‌ها با دو کاراکتر خط‌زیرین (Underscore or Underline ``_``) شروع و نیز پایان می‌یابد همانند: ``__init__`` - در کامیونیتی پایتون به دو کاراکتر خط‌زیرین در کنار هم به اصطلاح **Dunder** (Double underscores) گفته می‌شود - به این متدهای خاص در پایتون به اصطلاح Special Methods ،Dunder Methods یا Magic Methods گفته می‌شود. [`اسناد پایتون <https://docs.python.org/3/reference/datamodel.html#basic-customization>`__] باید توجه داشت که تمام این متدها یک پیاده‌سازی پیش‌فرض در پایتون دارند و الزامی برای پیاده‌سازی از طرف برنامه‌نویس وجود ندارد.

در فرآیند نمونه‌سازی از یک کلاس پایتون، به ترتیب دو متد خاص درگیر هستند: ``__new__`` [`اسناد پایتون <https://docs.python.org/3/reference/datamodel.html#object.__new__>`__] و ``__init__`` [`اسناد پایتون <https://docs.python.org/3/reference/datamodel.html#object.__init__>`__]


متد ``__new__`` در زمان ایجاد شی و دقیقا برای ایجاد شی فراخوانی می‌شود، خروجی این متد یک شی جدید از آن کلاس می‌باشد. این متد از نوع Class Method است - *در بخش بعدی شرح داده خواهد شد* - بنابراین نخستین پارامتر این متد کلاس جاری است که قرار است از آن یک شی ایجاد گردد و پارامترهای دیگر که می‌توانند حاوی مقادیری باشد که در زمان نمونه‌سازی ارسال شده است.

متد ``__init__`` بلافاصله پس از اینکه شی جدید توسط متد ``__new__`` ایجاد گردید و درست قبل از اینکه شی جدید از متد ``__new__``  بازگردانده شود (returned)، فراخوانی می‌گردد. این متد از نوع Instance Method است - *در بخش بعدی شرح داده خواهد شد* - و بنابراین نخستین پارامتر این متد شی جاری است (همان شی‌ای که توسط ``__new__``  ایجاد گردیده است) و پارامترهای دیگر که برنامه‌نویس در زمان نمونه‌سازی جهت مقدار دهی در شی ارسال می‌کند - توجه داشته باشید که این متد خروجی ندارد (بدون دستور return یا بهتر بگوییم خروجی آن None است) و شی جدید حاصل خروجی متد ``__new__`` خواهد بود.

متاسفانه برخی افراد تازه وارد در زبان پایتون و همینطور برخی آموزش‌ها متد ``__init__`` را به عنوان Constructor کلاس‌های پایتون می‌دانند اما درست این است که در فرآیند نمونه‌سازی در زبان برنامه‌نویسی پایتون، دو متد  ``__new__`` و  ``__init__`` با یکدیگر کار می‌کنند و نقش سازنده (Constructor) را ایفا می‌کنند. متد ``__new__`` شی را ایجاد (create) و متد ``__init__`` آن را شحصی‌سازی (customize) می‌کند:

.. code-block:: python
    :linenos:

    class Sample():
    
        def __new__(cls,*args,**kwargs):
            print("__new__(), Has been called")
            print('cls: ', cls)
            print('args: ', args)
            print('kwargs: ', kwargs)
    
            # create new object
            obj = super().__new__(cls)
    
            # return object
            return obj
    
        def __init__(self, x=0, y=0):
            print("__init__(), Has been called")
            print('self: ', self)
            self.x = x
            self.y = y
    
    
    sample_1 = Sample()
    print('-' * 30)
    sample_2 = Sample(3, 6)

::

    __new__(), Has been called
    cls:  <class '__main__.Sample'>
    args:  ()
    kwargs:  {}
    __init__(), Has been called
    self:  <__main__.Sample object at 0x7fb4580a6470>
    ------------------------------
    __new__(), Has been called
    cls:  <class '__main__.Sample'>
    args:  (3, 6)
    kwargs:  {}
    __init__(), Has been called
    self:  <__main__.Sample object at 0x7fb4580a64e0>

**این مثال صرفا جهت نمایش نقش Constructor و منطق و چگونگی پیاده‌سازی آن در زبان برنامه‌نویسی پایتون ارائه شده است. تمام موارد نا آشنایی که می‌بینید به تدریج شرح داده خواهند شد.**

.. tip:: 

  * زبان برنامه‌نویسی پایتون برخلاف برخی از زبان‌های دیگر شی‌گرا به مانند Java، از امکان پیاده‌سازی چندین Constructor پشتیبانی نمی‌کند.

  * همانطور که بیان شد، هر کلاس پایتون یک پیاده‌سازی پیش‌فرض از دو متد ``__new__`` و  ``__init__``  دارد بنابراین الزامی به پیاده‌سازی دو متد ``__new__`` و  ``__init__``  برای نمونه‌سازی از کلاس نیست. در اکثر مواقع ``__new__`` پیاده‌سازی نمی‌شود اما زمانی که می‌خواهید در زمان نمونه‌سازی مقادیری در شی تنظیم نمایید، لازم است متد ``__init__``  را پیاده‌سازی نمایید.

  * معمولا  ``__new__``  زمانی پیاده‌سازی می‌شود که بخواهیم محدودیت‌هایی در ایجاد شی کلاس مورد نظر ایجاد کنیم. برای نمونه در پیاده‌سازی طرح Singleton [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Singleton_pattern>`__] یک کلاس.
  
  * ارسال آرگومان در زمان نمونه‌سازی شی یا همان پیاده‌سازی متد ``__init__`` به برنامه‌نویس این اطمینان را می‌دهد که شی جدید در یک وضعیت درست تنظیم شده است. 



صفات (Attributes)
-----------------------------------------------------

به بیانی ساده، متغیرهایی که به یک کلاس یا یک شی انتساب داده می‌شود صفت یا ویژگی یا Attribute خوانده می‌شوند. در بحث شی گرایی زبان برنامه‌نویسی پایتون دو نوع Attribute وجود دارد:

* Instance Attribute
* Class Attribute




Instance Attribute
~~~~~~~~~~~~~~~~~~~~~

به Attributeهای خاص یک شی گفته می‌شود. به هر شی در زبان برنامه‌نویسی پایتون می‌توان با استفاده از سینتکس زیر یک Attribute انتساب داد::

  object.attribute_name = value
  

.. code-block:: python
	:linenos:
	
	class Sample(): pass
		
	sample = Sample()

	sample.a_new_attribute = 'A New Attribute!'

	print(sample.a_new_attribute)

::

	A New Attribute!
	
هر چیزی در پایتون یک شی است ولی ممکن است مفسر پایتون برای برخی اشیا محدودیت‌هایی در نظر گرفته باشد و شما نتوانید به هر  شی‌ای در پایتون Attribute اضافه نمایید. در این لحظه جا دارد اشاره شود به درس چهاردهم (بخش Function Attributes) که در واقع از این قانون اشیا در پایتون پیروی می‌کند.

.. tip:: 
  مقدار این دسته از Attributeها به ازای هر شی منحصر‌به‌فرد است. برای نمونه صفت‌هایی همچون نام، نام‌خانوادگی، سن و جنسیت برای هر یک از اشیای کلاس «شخص» قابل تعریف است. بدیهی است که هر نمونه شی از این کلاس می‌بایست شامل مقادیر منحصر‌به‌فردی از این Attributeها باشد.

برگردیم به مثال قبل که در آن ما یک کلاس به اسم Sample ایجاد (سطر ۱) و به یک شی از آن  - پس از نمونه‌سازی (سطر ۳) - یک Attribute به نام a_new_attribute اضافه کردیم (سطر ۵). این شیوه افزودن Attribute به اشیای کلاس‌هایی که خودمان آن‌ها را تعریف می‌کنیم چندان جالب نیست و ممکن است باعث بروز خطاهایی منطقی در برنامه گردد، بهتر است این کار توسط متد ``__init__`` که در واقع initializer اشیا پایتون است، انجام پذیرد - به نمونه کدهای زیر توجه نمایید:


.. code-block:: python
	:linenos:
	
	class Sample():
	
		def __init__(self, attribute_value):
			self.a_new_attribute = attribute_value
		
	sample = Sample()

	print(sample.a_new_attribute)

::

	A New Attribute!
	
	
.. code-block:: python
	:linenos:

	class Person():

		def __init__(self, first_name, last_name, age, gender):
			self.first_name = first_name
			self.last_name = last_name
			self.age = age
			self.gender = gender
	    
	person_1 = Person('Kaneki', 'Ken', 18, 'male')
	person_2 = Person('Haise', 'Sasaki', 19, 'male')
    
	print(person_1.first_name)
	print(person_2.last_name)


::

	Kaneki
	Sasaki


در ادامه شرح داده خواهد شد که پارامتر ``self`` به شی جاری اشاره دارد و به صورت خودکار توسط مفسر پایتون مقداردهی می‌شود.




Class Attribute
~~~~~~~~~~~~~~~~~~~~~







متد (Method)
-----------------------------------------------------

متدها در واقع توابعی هستند که داخل هر کلاس تعریف می‌شوند. هر کلاس پایتون می‌تواند شامل سه نوع متد باشد:

* Instance Method
* Class Method
* Static Method

.. code-block:: python
    :linenos:

    class Sample():
    
        def instance_method(self):
            pass
    
        @classmethod
        def class_method(cls):
            pass
    
        @staticmethod
        def static_method():
            pass
    


متد شی (Instance Method)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

رایج‌ترین نوع متد در پایتون است. برای ایجاد این متد نیازی به دکوراتور (Decorator‌ - درس سیزدهم) نیست. همانطور که از نام این متد مشخص است این متد تنها از سوی اشیا یک کلاس قابل استفاده است. هر شی از کلاس صفات (Attributes - *کمی جلوتر شرح داده خواهد شد*) خاص خود را دارد که از این متدها می‌توان برای دستیابی، دستکاری آن‌ها استفاده کرد.

این نوع متد همواره می‌بایست حداقل یک پارامتر داشته باشد. پارامتر نخست که معمولا ``self`` نام‌گذاری می‌شود حاوی شی جاری از کلاس است - در واقع همان شی ای که این متد را فراخوانی کرده است. این مقدار همواره از  سوی مفسر پایتون ارسال می‌گردد و نیازی به ارسال از سوی برنامه‌نویس ندارد:

.. code-block:: python
    :linenos:

    class Sample():
    
        def __init__(self, char='*'):
            self.character = char
    
        def multiply_print(self, count=1):
            print(self.character * count)
    
    
    sample_1 = Sample()  # Instantiating a new Object

    sample_1.multiply_print()
    sample_1.multiply_print(10)

    print('-' * 30)

    sample_2 = Sample('#')  # Instantiating a new Object

    sample_2.multiply_print()
    sample_2.multiply_print(10)

::

      *
      **********
      ------------------------------
      #
      ##########


گفته شده که متد ``__init__``  جزیی از مفهوم Constructor کلاس‌های پایتون بوده و برای شخصی‌سازی یک شی در زمان ایجاد آن به کار می‌رود - کاربرد معمول: افزودن Attribute (*که در بخش‌های آتی شرح داده می‌شود*) به شی است. در نمونه کد بالا، این متد یک پارامتر char دریافت می‌کند - این پارامتر مقدار پیش‌فرض ``*`` را دارد، بنابراین ارسال آرگومان متناظر برای آن اجباری نیست (تابع در پایتون - درس دوازدهم). با این کار می‌توانیم در زمان نمونه‌سازی شی، یک Attribute با نام character در آن تعریف نماییم (سطر ۴). ما می‌خواهیم مقدار Attribute یا صفت character از هر شی را به تعداد دلخواه چاپ نماییم، از آنجا که این مقدار یک صفتِ متعلق به شی است و در ازای هر شی این مقدار می‌تواند متفاوت باشد پس ما برای این کار می‌بایست که یک Instance Method در بدنه کلاس تعریف کنیم (متد ``multiply_print`` ) - چرا که تنها در این صورت است که می‌توانیم به ``self`` دسترسی داشته باشیم و مقدار صفت character را از آن دستیابی کنیم. 

.. tip:: 

  Instance Method‌ها تنها می‌توانند توسط اشیا فراخوانی شوند. روند فراخوانی یک متد توسط شی نیز به صورت نام شی + کاراکتر ``.‍‍`` + نام متد می‌باشد.



متد کلاس (Class Method)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~



متد ایستا (Static Method)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~




متدهای جادویی (Magic methods)
-----------------------------------------------------



هر چیزی در پایتون یک شی است
---------------------------------------------------------------------------------------



|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <https://www.coderz.ir/python-oop/>`_



