.. role:: emoji-size

.. meta::
   :description: کتاب آموزش زبان برنامه نویسی پایتون به فارسی، آموزش شی گرایی در پایتون، OOP در پایتون،  Decorators در پایتون، Descriptors در پایتون، Properties در پایتون
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, Decorators, کتابخانه, پایتون, شی گرایی در پایتون, Descriptors,Properties 


درس ۲۱: شی گرایی (OOP) در پایتون: __Descriptors ،Decorator ،__slots و Properties
===================================================================================================


توجه داشته باشید، هم اکنون پشتیبانی نسخه 2x پایتون به پایان رسیده است. بنابراین	همانند دروس پیش شی گرایی و به منظور جلوگیری از پیچیدگی‌های غیر ضروری، تمام مطالب این درس بر مبنای پایتون 3x ارائه می‌شود.



:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----


__slots__
----------------------------

پیش از هر توضیحی به نمونه کد زیر توجه نمایید:


.. code-block:: python
    :linenos: 

    class Sample:
        def __init__(self, a, b):
            self.a = a
            self.b = b


    objet = Sample(1, 2)
    print(objet.__dict__)

    print('-' * 30)

    objet.c = 3
    print(objet.__dict__)

    print('-' * 30)

    objet.__dict__['d'] = 4
    print(objet.__dict__)
    print(objet.d)

::

    {'a': 1, 'b': 2}
    ------------------------------
    {'a': 1, 'b': 2, 'c': 3}
    ------------------------------
    {'a': 1, 'b': 2, 'c': 3, 'd': 4}
    4

پیشتر نیز صحبت کرده بودیم، می‌توان پس از ایجاد یک شی به آن Attribute اضافه کنیم (به دو سطر ۱۲ و ۱۷ توجه نمایید). داده‌های مربوط به تمام Attributeهای یک شی توسط یک شی دیکشنری که از طریق ``__dict__`` در دسترس می‌باشد، نگهداری می‌شود.  

``__slots__`` [`اسناد پایتون <https://docs.python.org/3/reference/datamodel.html#slots>`__] یک Attribute ویژه در پایتون می‌باشد که با مقداردهی آن می‌توان از ایجاد ``__dict__`` جلوگیری و در نتیجه قابلیت افزودن Attribute جدید به شی را غیرفعال و تعداد Attributeهای آن را از همان نقطه ایجاد، ثابت نگه‌داشت:


.. code-block:: python
    :linenos: 

    class Sample:

        __slots__ = ('a', 'b')

        def __init__(self, a, b):
            self.a = a
            self.b = b


    objet = Sample(1, 2)
    print(objet.__dict__)

::

    Traceback (most recent call last):
      File "sample.py", line 11, in <module>
        print(objet.__dict__)
    AttributeError: 'Sample' object has no attribute '__dict__'


از مزایای ``__slots__`` می‌توان به کاهش مصرف حافطه (RAM) به خصوص در مورد کلاس‌هایی که قرار است اشیایی خیلی زیادی از آن‌ها ایجاد گردد، اشاره نمود.


از طریق ``__slots__`` همچنین می‌توان اجازه داد که کدام Attribute در آینده برای شی ایجاد گردد:

.. code-block:: python
    :linenos: 

    class Sample:

        __slots__ = ('a', 'b', 'c')

        def __init__(self, a, b):
            self.a = a
            self.b = b

    objet = Sample(1, 2)

    objet.c = 3

    print('a: ', objet.a)
    print('b: ', objet.b)
    print('c: ', objet.c)

    objet.d = 4

::


    a:  1
    b:  2
    c:  3
    Traceback (most recent call last):
      File "sample.py", line 17, in <module>
        objet.d = 4
    AttributeError: 'Sample' object has no attribute 'd'



**اکنون نمونه کد زیر را در وضعیت وراثت در نظر بگیرید:**

.. code-block:: python
    :linenos: 

    class Parent:
        def __init__(self, a, b):
            self.a = a
            self.b = b


    class Child(Parent):
        def __init__(self, a, b):
            super().__init__(a, b)


    child = Child(1, 2)
    print(child.__dict__)

    child.c = 3
    print(child.__dict__)

    print('a: ', child.a)
    print('b: ', child.b)
    print('c: ', child.c)

::

    {'a': 1, 'b': 2}
    {'a': 1, 'b': 2, 'c': 3}
    a:  1
    b:  2
    c:  3


اگر کلاس Parent شامل ``__slots__`` باشد و در نتیجه فاقد ``__dict__``:

.. code-block:: python
    :linenos: 

    class Parent:
        __slots__ = ('a', 'b')

        def __init__(self, a, b):
            self.a = a
            self.b = b


    class Child(Parent):

        def __init__(self, a, b):
            super().__init__(a, b)


    child = Child(1, 2)
    print(child.__dict__)

    child.c = 3
    print(child.__dict__)

    print('a: ', child.a)
    print('b: ', child.b)
    print('c: ', child.c)


::

     {}
     {'c': 3}
     a:  1
     b:  2
     c:  3

اگر هر دو کلاس شامل ``__slots__`` باشند:

.. code-block:: python
    :linenos: 

    class Parent:
        __slots__ = ('a', 'b')

        def __init__(self, a, b):
            self.a = a
            self.b = b


    class Child(Parent):
        __slots__ = ('c')

        def __init__(self, a, b):
            super().__init__(a, b)


    child = Child(1, 2)

    child.c = 3
    print('a: ', child.a)
    print('b: ', child.b)
    print('c: ', child.c)

::

    a:  1
    b:  2
    c:  3


**در وراثت چندگانه،** چنانچه ``__slots__`` مربوط به superclassها حاوی مقدار تکراری باشد، آنگاه باعث بروز خطا می‌گردد:

.. code-block:: python
    :linenos: 

    class ParentOne:
        __slots__ = ('a', 'b')

    class ParentTwo:
        __slots__ = ('z', 'b')


    class Child(ParentOne, ParentTwo):
        __slots__ = ('c')


    child = Child()

::

    Traceback (most recent call last):
      File "sample.py", line 8, in <module>
        class Child(ParentOne, ParentTwo):
    TypeError: multiple bases have instance lay-out conflict


بهتر است superclassها حاوی یک ``__slots__`` خالی (شی تاپل خالی) باشند و هر subclass خود محتوای ``__slots__`` خود را تعریف نماید:

.. code-block:: python
    :linenos: 

    class ParentOne:
        __slots__ = ()

    class ParentTwo:
        __slots__ = ()


    class Child(ParentOne, ParentTwo):
        __slots__ = ('a', 'b', 'z', 'c')


    child = Child()


|


[`مطلب مرتبط در StackOverflow <https://stackoverflow.com/a/28059785>`__]

Decorators
----------------------------

از درس سیزدهم با مفهوم Decoratorها و نیز کاربرد آن‌ها به همراه تابع در زبان برنامه‌نویسی پایتون آشنا شده‌ایم، در این بخش به بررسی Decoratorهابه همراه کلاس‌ها و متدها می‌پردازیم.

علاوه بر اینکه با استفاده از کلاس می‌توان یک Decorator ایجاد کرد، از Decorator‌ها نیز می‌توان بر روی کلاس یا متدهای داخل یک کلاس بهره گرفت. در ادامه به بررسی این موارد می‌پردازیم.


قراردادن Decorator بر روی متد
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

این کار همانند قراردادن Decorator بر روی تابع می‌باشد (درس سیزدهم) و تفاوتی ندارد. پیش‌تر نیز از Decoratorهایی همچون ``classmethod@`` یا ``staticmethod@`` بر روی متدها استفاده می‌کردیم. به مثالی در همین زمینه توجه نمایید:


.. code-block:: python
    :linenos:

    import functools

    def debug(func):
        """Print the function signature and return value
           Source: https://realpython.com/primer-on-python-decorators/#debugging-code"""

        @functools.wraps(func)
        def wrapper_debug(*args, **kwargs):
            args_repr = [repr(a) for a in args]                     
            kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
            signature = ", ".join(args_repr + kwargs_repr)      
            print(f"Calling {func.__name__}({signature})")
            value = func(*args, **kwargs)
            print(f"{func.__name__!r} returned {value!r}")       
            return value
        return wrapper_debug



    class Sample:

        @debug
        def __init__(self, x=0, y=0):
            self.x = x
            self.y = y


    sample = Sample(5, y=6)

::

    Calling __init__(<__main__.Sample object at 0x7fd96ddec8d0>, 5, y=6)
    '__init__' returned None

در نمونه کد بالا یک Decorator با نام ``debug`` ایجاد گردیده است (Decorator درس سیزدهم و f-string درس هفتم)، با قراردادن این Decorator بر روی یک تابع یا متد: نام تابع، آرگومان‌های ارسال شده و همچنین مقدار خروجی تابع را بر روی خروجی نمایش می‌دهد.



قراردادن Decorator بر روی کلاس
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



کلاس به عنوان Decorator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Descriptors
----------------------------



Properties
----------------------------



|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <https://www.coderz.ir/python-tutorial-oop-descriptors-properties>`_



