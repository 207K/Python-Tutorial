.. role:: emoji-size

.. meta::
   :description: کتاب آموزش زبان برنامه نویسی پایتون به فارسی، آموزش شی گرایی در پایتون، OOP در پایتون،  انتزاع در پایتون، Abstraction و Metaclass در پایتون، متاکلاس در پایتون
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, تابع, کتابخانه, پایتون, شی گرایی در پایتون


درس ۱۹: شی گرایی (OOP) در پایتون: Metaclass و Abstraction
========================================================================================================







:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----


متاکلاس (Metaclass)
----------------------------------

**متاکلاس (Metaclass)** [`اسناد پایتون <https://docs.python.org/3/reference/datamodel.html#metaclasses>`__] در پایتون یک مفهوم پنهان در رابطه با پیاده‌سازی برنامه‌نویسی شی گرا می‌باشد. اکثر برنامه‌نویس‌ها چه از آن آگاه باشند و چه خیر، به ندرت از آن استفاده می‌کنند و شاید شما هیچگاه نیاز به استفاده از این قابلیت نداشته باشید ولی باید بدانید این قابلیتی است که در اکثر زبان‌های برنامه‌نویسی شی گرا ارائه نمی‌شود! 

.. image:: /_static/l19-python-metaclass-type.jpg
    :align: center

**متاکلاس چیست؟** یک کلاس است و اشیایی که از آن ایجاد می‌گردند، کلاس‌ها هستند! بارها گفته شد که «هر چیزی در پایتون یک شی است» و این جمله حتی خود موجودیت کلاس‌ها را نیز شامل می‌شود. با اجرای دستور تعریف کلاس، یک شی از نوع ``type`` در حافظه ایجاد می‌گردد و از نام کلاس برای اشاره به آن شی استفاده می‌شود (درس هفدهم). اکنون می‌توانیم بگوییم که  ``type`` در واقع یک متاکلاس می‌باشد::

    >>> class MyClassName:
    ...     pass
    ... 
    >>> obj = MyClassName()

    >>> type(obj)
    <class '__main__.MyClassName'>
    
    >>> type(MyClassName)
    <class 'type'>


    >>> isinstance(obj, MyClassName)
    True

    >>> isinstance(MyClassName, type)
    True
 

در نمونه کد بالا، ``MyClassName`` کلاس یا نوع داده‌ای بود که ما خودمان آن را تعریف کرده بودیم. با این حال جالب است بدانید تمام انواع پیش تعریف شده در پایتون هم از نوع ``type`` هستند، حتی خود ``type``! ::

    >>> type(int)
    <class 'type'>
    >>> type(float)
    <class 'type'>
    >>> type(dict)
    <class 'type'>
    >>> type(list)
    <class 'type'>
    >>> type(tuple)
    <class 'type'>
    >>> type(str)
    <class 'type'>
    >>> type(complex)
    <class 'type'>
    >>> type(bool)
    <class 'type'>
    
    >>> type(type)
    <class 'type'>


در واقع ``type`` کلاسی است که تمام کلاس‌های پایتون به صورت پیش‌فرض از روی آن ایجاد می‌گردند. ``type`` یک متا کلاس است و پایتون این قابلیت را به شما می‌دهد که متا کلاس خودتان را بسازید، بنابراین می‌توانید کلاس‌هایی بسازید که یک شی از متا کلاس شما هستند، هیجان انگیز نیست؟! اکثر زبان‌های برنامه‌نویسی تنها یک پیاده‌سازی پیش‌فرض در اختیار برنامه‌نویس قرار می‌دهند ولی این قابلیت در پایتون امکانات قدرتمندی برای برنامه‌نویس فراهم می‌آورد همچون thread-safety، مدیریت کامل فرآیند ایجاد شی و...

ایجاد متاکلاس
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

	>>> class SampleMetaClass(type):
	...     pass
	... 
	>>> class Sample(metaclass=SampleMetaClass):
	...      pass
	... 
	>>> 
	
	>>> type(SampleMetaClass)
	<class 'type'>
	
	>>> type(Sample)
	<class '__main__.SampleMetaClass'>

برای ایجاد متا کلاس تنها کافی است یک کلاس جدید بسازید که از کلاس ``type`` ارث‌بری داشته باشد. با ارسال نام این کلاس به پارامتر ``metaclass`` هر کلاس دیگری می‌توان به آن‌ها انتساب داد.

بحث اشیای Callable را از درس هفدهم به یاد آورید -  هر کلاس در پایتون یک شی از متاکلاس مربوط به خودش می‌باشد، همچنین گفته شد کلاس‌ها در پایتون Callable هستند، بنابراین هرگاه یک کلاس فراخوانی می‌شود (در واقع زمانی که یک شی از آن کلاس ایجاد می‌گردد)، به صورت خودکار متد ``__call__`` متا کلاس آن نیز فراخوانی می‌گردد.

اکنون زمانی است که می‌توانید تمام فرآیند ایجاد یک شی در پایتون را بدانید، آن را در دست بگیرید و هر کاری که نیاز دارید را به انجام برسانید!:


.. code-block:: python
    :linenos: 
    
    class MetaClass(type):

        def __call__(self, *args, **kwargs):
            print('\n------->>> MetaClass __call__')
            print('self: ', self)
            print('args: ', args)
            print('kwargs: ', kwargs)
            
            obj = self.__new__(self, *args, **kwargs)    
    
            if obj is not None and isinstance(obj, self) and hasattr(obj, '__init__'):
                 obj.__init__(*args, **kwargs)
             
            return obj


    class Sample(metaclass=MetaClass):

        def __new__(cls, *args, **kwargs): 
            print('\n------->>> Sample __new__')
            print('cls: ', cls)
            print('args: ', args)
            print('kwargs: ', kwargs)
            
            obj = super().__new__(cls)
            return obj
        
        def __init__(self, x=0, y=0, z=0):
            print('\n------->>> Sample __init__')
            print('self: ', self)
            print('x: ', x)
            print('y: ', y)
            print('z: ', z)
            
            self.x = x
            self.y = y
            self.z = z


    sample_obj = Sample('p_arg_1', 'p_arg_2', z='k_arg')



::

    ------->>> MetaClass __call__
    self:  <class '__main__.Sample'>
    args:  ('p_arg_1', 'p_arg_2')
    kwargs:  {'z': 'k_arg'}

    ------->>> Sample __new__
    cls:  <class '__main__.Sample'>
    args:  ('p_arg_1', 'p_arg_2')
    kwargs:  {'z': 'k_arg'}

    ------->>> Sample __init__
    self:  <__main__.Sample object at 0x7f578772f3d0>
    x:  p_arg_1
    y:  p_arg_2
    z:  k_arg









بر اساس تعریف ارائه شده در [`اسناد پایتون <https://docs.python.org/3/glossary.html#term-metaclass>`__]، تعریف کلاس (دستور ``class``) باعث ایجاد «نام کلاس»، «یک شی دیکشنری از کلاس» و «یک  شی لیست حاوی superclassهای آن کلاس» می‌شود، متاکلاس این سه آرگومان را دریافت و شی کلاس را ایجاد می‌کند.




انتزاع (Abstraction)
----------------------------------



|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه

`لطفا دیدگاه و سوال‌های مرتبط با این درس خود را در کدرز مطرح نمایید. <https://www.coderz.ir/python-tutorial-oop-metaclass-abstraction>`_



