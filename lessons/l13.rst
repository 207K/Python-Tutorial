.. role:: emoji-size

.. meta::
   :description: کتاب آنلاین و آزاد آموزش زبان برنامه‌نویسی پایتون به فارسی - درس سیزدهم تابع
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, انواع شی, انواع داده, پایتون


درس ۱۳: تابع - بخش دوم
========================








:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----




Decorator
----------


دکوراتور (تزئین‌گر) یا همان **Decorator‌** ها [`PEP 318 <https://www.python.org/dev/peps/pep-0318//>`__] به توابعی گفته می‌شود که به منظور پوشش (wrap) توابع یا کلاس‌های دیگر پیاده‌سازی می‌شوند. Decorator‌ها در پایتون ابزار بسیار کاربردی و مفیدی هستند که به برنامه‌نویس این امکان را می‌دهند تا با کاهش حجم کدنویسی و بدون تغییر در بدنه توابع و کلاس‌های خود، رفتار و ویژگی‌های آن‌ها را گسترش دهد. در این بخش تمرکز بر روی اعمال Decorator‌ها به توابع است و Decorator‌ کلاس را در درس مربوط به کلاس‌ها بررسی خواهیم کرد.

برای پوشش یک تابع توسط Decorator‌ از سینتکسی مشابه ``decorator‌_name@`` در بالای بخش سرآیند استفاده می‌شود:

::

  def decorator_name(a_function):
      pass


  @decorator_name
  def function_name():
      print("Somthing!")


  function_name()

مفهومی که این سینتکس (``decorator‌_name`` + ``@``) در بالای بخش سرآیند یک تابع برای مفسر پایتون ایجاد می‌کند کاملا مشابه با سینتکس پایین است::

  wrapper = decorator_name(function_name)
  wrapper()

هر چیزی در پایتون یک شی است حتی مفاهیم پیچیده‌ای به مانند تابع؛ از درس پیش نیز به خاطر داریم که تابع در پایتون یک موجودیت **”first-class“** است که یعنی می‌توان تابع را مانند دیگر اشیا به صورت آرگومان به توابع دیگر ارسال نمود. نمونه کد بالا نیز نمایش ارسال یک تابع (``function_name``) به تابعی دیگر (``decorator‌_name``) است.


به مثال پایین توجه نمایید:

::

  >>> def decorator_name(func):
  ...     def wrapper():
  ...         print("Something is happening before the function is called.")
  ...         func()
  ...         print("Something is happening after the function is called.")
  ...     return wrapper
  ... 
  >>> 
  >>> @decorator_name
  ... def function_name():
  ...     print("Somthing!")
  ... 
  >>> 
  >>> function_name()
  Something is happening before the function is called.
  Somthing!
  Something is happening after the function is called.
  >>> 

نمونه کد بالا را می‌توان با ساختار ساده زیر نیز در نظر گرفت:

::

  >>> def decorator_name(func):
  ...     def wrapper():
  ...         print("Something is happening before the function is called.")
  ...         func()
  ...         print("Something is happening after the function is called.")
  ...     return wrapper
  ... 
  >>> 
  >>> def function_name():
  ...     print("Somthing!")
  ... 
  >>> 
  >>> wrapper = decorator_name(function_name)
  >>> wrapper()
  Something is happening before the function is called.
  Somthing!
  Something is happening after the function is called.
  >>> 

همانطور که با مقایسه دو نمونه کد بالا قابل مشاهده است، Decorator‌ها یک روپوش (wrapper) برای توابع و کلاس‌های ما بوجود می‌آورند. در هنگام فراخوانی تابع ``function_name`` مفسر پایتون متوجه decorator‌ آن شده است و به جای اجرا، یک نمونه شی از آن را به decorator‌ مشخص شده (``decorator‌_name``) ارسال می‌کند و یک شی جدید که در اینجا با تابع ``wrapper`` مشخص شده است را دریافت و اجرا می‌کند.

در مورد توابع دارای پارامتر نیز باید توجه داشت که در هنگام فراخوانی تابع مورد نظر و ارسال آرگومان به تابع، مفسر پایتون این آرگومان‌ها را به تابع ``wrapper`` از decorator‌ ارسال می‌کند::

  >>> def multiply_in_2(func):
  ...     def wrapper(*args):
  ...         return func(*args) * 2
  ...     return wrapper 
  ... 
  >>> 
  >>> @multiply_in_2
  ... def sum_two_numbers(a, b):
  ...     return a + b
  ... 
  >>> 
  >>> sum_two_numbers(2, 3)
  10

::

  >>> # normal
  >>>
  >>> def multiply_in_2(func):
  ...     def wrapper(*args):
  ...         return func(*args) * 2
  ...     return wrapper 
  ... 
  >>> 
  >>> def sum_two_numbers(a, b):
  ...     return a + b
  ... 
  >>> 
  >>> wrapper = multiply_in_2(sum_two_numbers)
  >>> wrapper(2, 3)
  10




می‌توان بیش از یک Decorator‌ به کلاس‌ها و توابع خود اعمال کرد که در این صورت ترتیب قرار گرفتن این Decorator‌ها برای مفسر پایتون دارای اهمیت است::

  @decorator_3
  @decorator_2
  @decorator_1
  def function_name():
      print("Somthing!")


  function_name()


::

  wrapper = decorator_3(decorator_2(decorator_1(function_name)))
  wrapper()


همچنین می‌توان به Decorator‌ها آرگومان نیز ارسال کرد::

  @decorator_name(params)
  def function_name():
      print("Somthing!")


  function_name()

در این حالت مفسر پایتون ابتدا آرگومان را به تابع Decorator‌ ارسال می‌کند و سپس حاصل را با آرگومان ورودی تابع مورد نظر فراخوانی می‌کند::

  temp_decorator = decorator_name(params)
  wrapper = temp_decorator(function_name)
  wrapper()

به نمونه کد پایین توجه نمایید::

  >>> def formatting(lowerscase=False):
  ...     def formatting_decorator(func):
  ...         def wrapper(text=''):
  ...             if lowerscase:
  ...                 func(text.lower())
  ...             else:
  ...                 func(text.upper())
  ...         return wrapper 
  ...     return formatting_decorator
  ... 
  >>> 
  >>> @formatting(lowerscase=True)
  ... def chaap(message):
  ...     print(message)
  ... 
  >>> 
  >>> chaap("I Love Python")
  i love python
  >>> 


Generator
----------

ژنراتور (مولد) یا همان **Generator‌** ها [`PEP 255 <https://www.python.org/dev/peps/pep-0255/>`__] به توابعی گفته می‌شود که به منظور ایجاد یک تابع با رفتاری مشابه اشیا ``iterator`` (تکرارکننده - درس نهم) پیاده‌سازی می‌شوند.

بر خلاف شی‌ای به مانند لیست، عملکرد Generator‌ به صورت **lazy** (کندرو) [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Lazy_evaluation>`__] می‌باشد و داده‌ها را یکجا ذخیره نمی‌کند بلکه آنها را تنها در همان زمانی که درخواست می‌شوند، **تولید** (Generate) می‌کند. بنابراین در هنگام برخورد با مجموعه داده‌های بزرگ، Generator‌ها مدیریت حافظه کارآمدتری دارند و همچنین ما مجبور نیستیم پیش از استفاده از یک دنباله منتظر بمانیم تا تمام مقادیر آن تولید شوند!.

برای ایجاد یک تابع Generator تنها کافی است در یک تابع معمولی از دستور ``yield`` استفاده کنیم. اکنون مفسر پایتون در هنگام فراخوانی این تابع یک شی ``generator`` برمی‌گرداند که توانایی تولید یک **دنباله** (Sequence) از مقادیر (شی) برای استفاده در کاربردهای تکرارپذیر را دارد.

دستور ``yield`` روند اجرای برنامه را با حفظ وضعیت، متوقف می‌کند و  می‌توانیم با استفاده از متد ``()__next__`` (یا ``()next`` در پایتون 2x) روند اجرای تابع را در دست بگیریم::


  >>> def a_generator_function():
  ...    for i in range(3):
  ...       yield i*i
  ...    return
  ... 
  >>> my_generator = a_generator_function()  # Create a generator
  >>> 
  >>> my_generator.__next__()  #  Use my_generator.next() in Python 2.x
  0
  >>> my_generator.__next__()
  1
  >>> my_generator.__next__()
  4
  >>> my_generator.__next__()
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  StopIteration
  >>> 



همانطور که در انتهای درس نهم (بخش «شی تکرارکننده») نیز اشاره شده بود،  می‌توانیم مقادیر دنباله مورد نظر خود را با استفاده از متد ``()__next__`` (یا ``()next`` در پایتون 2x) درخواست نماییم. باید توجه داشت که پایان این دنباله توسط استثنا ``StopIteration`` گزارش می‌شود. در زمان استفاده از دستور ``for`` این استثنا کنترل شده و حلقه پایان می‌پذیرد. نمونه کد قبل را به صورت زیر بازنویسی می‌کنیم::

  >>> def a_generator_function():
  ...    for i in range(3):  # i: 0, 1, 2
  ...       yield i*i
  ...    return
  ... 
  >>> 
  >>> my_generator = a_generator_function()  # Create a generator
  >>> 
  >>> type(my_generator)
  <class 'generator'>
  >>> 
  >>> for i in my_generator:
  ...     print(i)
  ... 
  0
  1
  4
  >>> 


ویژگی‌های تابع Generator‌
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  

* تابع Generator‌ یک تابع معمولی است که رفتاری مشابه با یک شی تکرارکننده (iterator) دارد.

* تابع Generator‌ شامل یک یا چند دستور ``yield`` می‌باشد.

* در زمان فراخوانی تابع Generator‌، تابع اجرا نمی‌شود ولی در عوض یک شی از نوع ``generator`` برای آن تابع برگردانده می‌شود.

* با استفاده از دستور ``yield`` می‌توانیم در هر نقطه‌ای از تابع Generator‌ که بخواهیم توقف ایجاد کنیم - بدون از دست رفتن وضعیت فعلی تابع - و سپس با استفاده از متد ``()__next__`` (یا ``()next`` در پایتون 2x) به ادامه روند اجرا برگردیم. 

* با نخستین فراخوانی متد ``()__next__`` تابع اجرا می‌شود، تا زمانی که به یک دستور ``yield`` برسد. در این زمان  دستور ``yield`` یک نتیجه تولید می‌کند و اجرای تابع متوقف می‌شود. با فراخوانی مجدد  متد ``()__next__`` اجرای تابع از ادامه دستور ``yield`` سر گرفته می‌شود.

* معمولا نیازی به استفاده مستقیم از متد ``()__next__`` نمی‌شود و توابع Generator‌ از طریق دستورهایی به مانند ``for`` یا  توابعی به مانند ``()sum`` و... که توانایی دریافت یک **دنباله** (Sequence) را دارند، مورد استفاده قرار می‌گیرند.

* در پایان تولید توابع Generator‌ یک  استثنا ``StopIteration`` در نقطه توقف خود گزارش می‌دهند که می‌بایست درون برنامه کنترل شود.

* فراموش نکنیم که استفاده از دستور ``return`` در هر کجا از بدنه تابع باعث پایان یافتن اجرای تابع در آن نقطه می‌شود و توابع Generator‌ نیز از این امر مسثنا نیستند .



به یک نمونه کد دیگر نیز توجه نمایید::

  >>> def countdown(n):
  ...     print("Counting down from %d" % n)
  ...     while n > 0:
  ...        yield n
  ...        n -= 1
  ...     return
  ... 
  >>> 
  >>> countdown_generator = countdown(10)
  >>> 
  >>> countdown_generator.__next__()
  Counting down from 10
  10
  >>> countdown_generator.__next__()
  9
  >>> countdown_generator.__next__()
  8
  >>> countdown_generator.__next__()
  7
  >>> 


در ادامه Yield و Coroutines
------------------------------------





|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه



