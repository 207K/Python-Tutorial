.. role:: emoji-size

.. meta::
   :description: کتاب آنلاین و آزاد آموزش زبان برنامه‌نویسی پایتون به فارسی - درس سیزدهم تابع
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, انواع شی, انواع داده, پایتون


درس ۱۳: تابع - بخش دوم
========================








:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----




Decorator (تزئین‌گر)
--------------------


تزئین‌گرها یا همان **Decorator‌** ها توابعی هستند که به منظور پوشش (wrap) توابع یا کلاس‌های دیگر پیاده‌سازی می‌شوند. Decorator‌ها در پایتون ابزار بسیار کاربردی و مفیدی هستند که به برنامه‌نویس این امکان را می‌دهند تا بدون تغییر در بدنه توابع و کلاس‌های خود، رفتار و ویژگی‌های آن‌ها را گسترش دهد.

برای پوشش یک تابع توسط Decorator‌ از سینتکسی مشابه ``decorator‌_name@`` در بالای بخش سرآیند استفاده می‌شود:

::

  @decorator_name
  def function_name():
      print("Somthing!")


  function_name()

مفهومی که این سینتکس (``decorator‌_name`` + ``@``) در بالای بخش سرآیند یک تابع برای مفسر پایتون ایجاد می‌کند کاملا مشابه با سینتکس پایین است::

  wrapper = decorator_name(function_name)
  wrapper()

هر چیزی در پایتون یک شی است حتی مفاهیم پیچیده‌ای به مانند تابع؛ از درس پیش نیز به خاطر داریم که تابع در پایتون یک موجودیت **”first-class“** است که یعنی می‌توان تابع را مانند دیگر اشیا به صورت آرگومان به توابع دیگر ارسال نمود. نمونه کد بالا نیز نمایش ارسال یک تابع (``function_name``) به تابعی دیگر (``decorator‌_name``) است.


به مثال پایین توجه نمایید:

::

  >>> def decorator_name(func):
  ...     def wrapper():
  ...         print("Something is happening before the function is called.")
  ...         func()
  ...         print("Something is happening after the function is called.")
  ...     return wrapper
  ... 
  >>> 
  >>> @decorator_name
  ... def function_name():
  ...     print("Somthing!")
  ... 
  >>> 
  >>> function_name()
  Something is happening before the function is called.
  Somthing!
  Something is happening after the function is called.
  >>> 

نمونه کد بالا را می‌توان با ساختار ساده زیر نیز در نظر گرفت:

::

  >>> def decorator_name(func):
  ...     def wrapper():
  ...         print("Something is happening before the function is called.")
  ...         func()
  ...         print("Something is happening after the function is called.")
  ...     return wrapper
  ... 
  >>> 
  >>> def function_name():
  ...     print("Somthing!")
  ... 
  >>> 
  >>> wrapper = decorator_name(function_name)
  >>> wrapper()
  Something is happening before the function is called.
  Somthing!
  Something is happening after the function is called.
  >>> 

همانطور که با مقایسه دو نمونه کد بالا قابل مشاهده است، Decorator‌ها یک روپوش (wrapper) برای توابع و کلاس‌های ما بوجود می‌آورند. در هنگام فراخوانی تابع ``function_name`` مفسر پایتون متوجه decorator‌ آن شده است و به جای اجرا، یک نمونه شی از آن را به decorator‌ مشخص شده (``decorator‌_name``) ارسال می‌کند و یک شی جدید که در اینجا با عنوان ``wrapper`` مشخص شده است را دریافت و اجرا می‌کند.




|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه



