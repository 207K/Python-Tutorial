.. role:: emoji-size

.. meta::
   :description: کتاب آنلاین و آزاد آموزش زبان برنامه‌نویسی پایتون به فارسی - درس سیزدهم تابع
   :keywords:  آموزش, آموزش پایتون, آموزش برنامه نویسی, پایتون, انواع شی, انواع داده, پایتون


درس ۱۳: تابع - بخش دوم
========================








:emoji-size:`✔` سطح: متوسط

----


.. contents:: سرفصل‌ها
    :depth: 2

----




Decorator
----------


دکوراتور (تزئین‌گر) یا همان **Decorator‌** ها [`PEP 318 <https://www.python.org/dev/peps/pep-0318//>`__] به توابعی گفته می‌شود که به منظور پوشش (wrap) توابع یا کلاس‌های دیگر پیاده‌سازی می‌شوند. Decorator‌ها در پایتون ابزار بسیار کاربردی و مفیدی هستند که به برنامه‌نویس این امکان را می‌دهند تا با کاهش حجم کدنویسی و بدون تغییر در بدنه توابع و کلاس‌های خود، رفتار و ویژگی‌های آن‌ها را گسترش دهد. در این بخش تمرکز بر روی اعمال Decorator‌ها به توابع است و Decorator‌ کلاس را در درس مربوط به کلاس‌ها بررسی خواهیم کرد.

برای پوشش یک تابع توسط Decorator‌ از سینتکسی مشابه ``decorator‌_name@`` در بالای بخش سرآیند استفاده می‌شود:

::

  def decorator_name(a_function):
      pass


  @decorator_name
  def function_name():
      print("Somthing!")


  function_name()

مفهومی که این سینتکس (``decorator‌_name`` + ``@``) در بالای بخش سرآیند یک تابع برای مفسر پایتون ایجاد می‌کند کاملا مشابه با سینتکس پایین است::

  wrapper = decorator_name(function_name)
  wrapper()

هر چیزی در پایتون یک شی است حتی مفاهیم پیچیده‌ای به مانند تابع؛ از درس پیش نیز به خاطر داریم که تابع در پایتون یک موجودیت **”first-class“** است که یعنی می‌توان تابع را مانند دیگر اشیا به صورت آرگومان به توابع دیگر ارسال نمود. نمونه کد بالا نیز نمایش ارسال یک تابع (``function_name``) به تابعی دیگر (``decorator‌_name``) است.


به مثال پایین توجه نمایید:

::

  >>> def decorator_name(func):
  ...     def wrapper():
  ...         print("Something is happening before the function is called.")
  ...         func()
  ...         print("Something is happening after the function is called.")
  ...     return wrapper
  ... 
  >>> 
  >>> @decorator_name
  ... def function_name():
  ...     print("Somthing!")
  ... 
  >>> 
  >>> function_name()
  Something is happening before the function is called.
  Somthing!
  Something is happening after the function is called.
  >>> 

نمونه کد بالا را می‌توان با ساختار ساده زیر نیز در نظر گرفت:

::

  >>> def decorator_name(func):
  ...     def wrapper():
  ...         print("Something is happening before the function is called.")
  ...         func()
  ...         print("Something is happening after the function is called.")
  ...     return wrapper
  ... 
  >>> 
  >>> def function_name():
  ...     print("Somthing!")
  ... 
  >>> 
  >>> wrapper = decorator_name(function_name)
  >>> wrapper()
  Something is happening before the function is called.
  Somthing!
  Something is happening after the function is called.
  >>> 

همانطور که با مقایسه دو نمونه کد بالا قابل مشاهده است، Decorator‌ها یک روپوش (wrapper) برای توابع و کلاس‌های ما بوجود می‌آورند. در هنگام فراخوانی تابع ``function_name`` مفسر پایتون متوجه decorator‌ آن شده است و به جای اجرا، یک نمونه شی از آن را به decorator‌ مشخص شده (``decorator‌_name``) ارسال می‌کند و یک شی جدید که در اینجا با تابع ``wrapper`` مشخص شده است را دریافت و اجرا می‌کند.

در مورد توابع دارای پارامتر نیز باید توجه داشت که در هنگام فراخوانی تابع مورد نظر و ارسال آرگومان به تابع، مفسر پایتون این آرگومان‌ها را به تابع ``wrapper`` از decorator‌ ارسال می‌کند::

  >>> def multiply_in_2(func):
  ...     def wrapper(*args):
  ...         return func(*args) * 2
  ...     return wrapper 
  ... 
  >>> 
  >>> @multiply_in_2
  ... def sum_two_numbers(a, b):
  ...     return a + b
  ... 
  >>> 
  >>> sum_two_numbers(2, 3)
  10

::

  >>> # normal
  >>>
  >>> def multiply_in_2(func):
  ...     def wrapper(*args):
  ...         return func(*args) * 2
  ...     return wrapper 
  ... 
  >>> 
  >>> def sum_two_numbers(a, b):
  ...     return a + b
  ... 
  >>> 
  >>> wrapper = multiply_in_2(sum_two_numbers)
  >>> wrapper(2, 3)
  10




می‌توان بیش از یک Decorator‌ به کلاس‌ها و توابع خود اعمال کرد که در این صورت ترتیب قرار گرفتن این Decorator‌ها برای مفسر پایتون دارای اهمیت است::

  @decorator_3
  @decorator_2
  @decorator_1
  def function_name():
      print("Somthing!")


  function_name()


::

  wrapper = decorator_3(decorator_2(decorator_1(function_name)))
  wrapper()


همچنین می‌توان به Decorator‌ها آرگومان نیز ارسال کرد::

  @decorator_name(params)
  def function_name():
      print("Somthing!")


  function_name()

در این حالت مفسر پایتون ابتدا آرگومان را به تابع Decorator‌ ارسال می‌کند و سپس حاصل را با آرگومان ورودی تابع مورد نظر فراخوانی می‌کند::

  temp_decorator = decorator_name(params)
  wrapper = temp_decorator(function_name)
  wrapper()

به نمونه کد پایین توجه نمایید::

  >>> def formatting(lowerscase=False):
  ...     def formatting_decorator(func):
  ...         def wrapper(text=''):
  ...             if lowerscase:
  ...                 func(text.lower())
  ...             else:
  ...                 func(text.upper())
  ...         return wrapper 
  ...     return formatting_decorator
  ... 
  >>> 
  >>> @formatting(lowerscase=True)
  ... def chaap(message):
  ...     print(message)
  ... 
  >>> 
  >>> chaap("I Love Python")
  i love python
  >>> 


Generator
----------

ژنراتور (مولد) یا همان **Generator‌** ها [`PEP 255 <https://www.python.org/dev/peps/pep-0255/>`__] به توابعی گفته می‌شوند که به منظور ایجاد یک تابع با رفتاری مشابه اشیا ``iterator`` (تکرارکننده - درس نهم) پیاده‌سازی می‌گردند.

هنگام فراخوانی یک تابع معمولی، بدنه تابع اجرا می‌شود تا به یک دستور ``return`` برسد و خاتمه یابد ولی با فراخوانی یک تابع Generator‌، بدنه تابع اجرا نمی‌شود بلکه یک شی ``generator`` برگردانده خواهد شد که  می‌توان با استفاده از متد ``()__next__`` (یا ``()next`` در پایتون 2x) آن، مقادیر مورد انتظار خود را یکی پس از دیگری درخواست داد.

عملکرد Generator‌ به صورت **lazy** (کندرو) [`ویکی‌پدیا <https://en.wikipedia.org/wiki/Lazy_evaluation>`__] می‌باشد و داده‌ها را یکجا ذخیره نمی‌کند بلکه آنها را تنها در همان زمانی که درخواست می‌شوند، **تولید** (Generate) می‌کند. بنابراین در هنگام برخورد با مجموعه داده‌های بزرگ، Generator‌ها مدیریت حافظه کارآمدتری دارند و همچنین ما مجبور نیستیم پیش از استفاده از یک دنباله منتظر بمانیم تا تمام مقادیر آن تولید شوند!.

برای ایجاد یک تابع Generator تنها کافی است در یک تابع معمولی از یک یا چند دستور ``yield`` استفاده کنیم. اکنون مفسر پایتون در هنگام فراخوانی چنین تابعی یک شی ``generator`` برمی‌گرداند که توانایی تولید یک **دنباله** (Sequence) از مقادیر (یا شی) برای استفاده در کاربردهای تکرارپذیر را دارد.

سینتکس دستور ``yield`` شبیه دستور ``return`` است ولی با کاربردی متفاوت. این دستور در هر نقطه‌ای از بدنه تابع که باشد،  اجرای برنامه را  در آن نقطه متوقف می‌کند و  ما می‌توانیم با استفاده از متد ``()__next__`` (یا ``()next`` در پایتون 2x) مقدار **yield (حاصل) شده** را دریافت نماییم::


  >>> def a_generator_function():
  ...    for i in range(3):  # i: 0, 1, 2
  ...       yield i*i
  ...    return
  ... 
  >>> my_generator = a_generator_function()  # Create a generator
  >>> 
  >>> my_generator.__next__()  #  Use my_generator.next() in Python 2.x
  0
  >>> my_generator.__next__()
  1
  >>> my_generator.__next__()
  4
  >>> my_generator.__next__()
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  StopIteration
  >>> 

باید توجه داشت که پایان فرآیند تولید  تابع Generator توسط استثنا ``StopIteration`` گزارش می‌شود. البته در زمان استفاده از دستورهایی به مانند ``for`` این استثنا کنترل شده و حلقه پایان می‌پذیرد. نمونه کد قبل را به صورت زیر بازنویسی می‌کنیم::

  >>> def a_generator_function():
  ...    for i in range(3):  # i: 0, 1, 2
  ...       yield i*i
  ...    return
  ... 
  >>> 
  >>> for i in a_generator_function():
  ...     print(i)
  ... 
  0
  1
  4
  >>> 

به منظور درک بهتر عملکرد  تابع Generator‌، تصور کنید از شما خواسته شده است که یک تابع شخصی مشابه با تابع ``()range`` پایتون پیاده‌سازی نمایید. راهکار شما چه خواهد بود؟  ایجاد یک شی‌ای مانند لیست (list) یا تاپل خالی و پر کردن آن با استفاده از یک حلقه؟! این راهکار شاید برای ایجاد بازه‌های کوچک پاسخگو باشد ولی برای ایجاد یک بازه صد میلیونی آیا حافظه و زمان کافی در اختیار دارید؟. این مسئله را با استفاده از تابع Generator‌ به سادگی و درستی حل خواهیم کرد::

  >>> def my_range(stop):
  ...     number = 0
  ...     while number < stop:
  ...         yield number
  ...         number = number + 1
  ...     return
  ... 
  >>> 
  >>> for number in my_range(100000000):
  ...     print(number)




ویژگی‌های تابع Generator‌
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* تابع Generator‌ شامل یک یا چند دستور ``yield`` می‌باشد.

* در زمان فراخوانی تابع Generator‌، تابع اجرا نمی‌شود ولی در عوض یک شی از نوع ``generator`` برای آن تابع برگردانده می‌شود.

* با استفاده از دستور ``yield`` می‌توانیم در هر نقطه‌ای از تابع Generator‌ که بخواهیم توقف ایجاد کنیم و مقدار  **yield (حاصل) شده** را با استفاده از متد ``()__next__`` (یا ``()next`` در پایتون 2x) دریافت نماییم. 

* با نخستین فراخوانی متد ``()__next__`` تابع اجرا می‌شود، تا زمانی که به یک دستور ``yield`` برسد. در این زمان  دستور ``yield`` یک نتیجه تولید می‌کند و اجرای تابع متوقف می‌شود. با فراخوانی مجدد  متد ``()__next__`` اجرای تابع از ادامه همان دستور ``yield`` سر گرفته می‌شود.

* معمولا نیازی به استفاده مستقیم از متد ``()__next__`` نمی‌شود و توابع Generator‌ از طریق دستورهایی به مانند ``for`` یا  توابعی به مانند ``()sum`` و... که توانایی دریافت یک **دنباله** (Sequence) را دارند، مورد استفاده قرار می‌گیرند.

* در پایان تولید توابع Generator‌ یک  استثنا ``StopIteration`` در نقطه توقف خود گزارش می‌دهند که می‌بایست درون برنامه کنترل شود.

* فراموش نکنیم که استفاده از دستور ``return`` در هر کجا از بدنه تابع باعث پایان یافتن اجرای تابع در آن نقطه می‌شود و توابع Generator‌ نیز از این امر مسثنا نیستند!.



به یک نمونه کد دیگر نیز توجه نمایید::

  >>> def countdown(n):
  ...     print("Counting down from %d" % n)
  ...     while n > 0:
  ...        yield n
  ...        n -= 1
  ...     return
  ... 
  >>> 
  >>> countdown_generator = countdown(10)
  >>> 
  >>> countdown_generator.__next__()
  Counting down from 10
  10
  >>> countdown_generator.__next__()
  9
  >>> countdown_generator.__next__()
  8
  >>> countdown_generator.__next__()
  7
  >>> 




در ادامه Coroutine :yield
------------------------------------

از نسخه پایتون 2.5 ویژگی‌های جدیدی به تابع Generator‌ افزوده شد [`PEP 342 <https://www.python.org/dev/peps/pep-0342/>`__]. اگر داخل یک تابع، دستور ``yield`` را در سمت راست یک عملگر انتساب ``=`` قرار دهیم آنگاه تابع مذکور رفتار متفاوتی از خود نشان می‌دهد که به آن در زبان برنامه‌نویسی پایتون **Coroutine** گفته شود. تصور کنید که اکنون می‌توانیم مقادیر دلخواه خود را به تابع Generator‌ ارسال کنیم!::

  >>> def receiver():
  ...     print("Ready to receive")
  ...     while True:
  ...         n = (yield)
  ...         print("Got %s" % n)
  ... 
  >>> 


  >>> receiver_generator = receiver()

  >>> receiver_generator.__next__() # python 3.x - In Python 2.x use .next()
  Ready to receive

  >>> receiver_generator.send('WooW!!')
  Got WooW!!

  >>> receiver_generator.send(1)
  Got 1

  >>> receiver_generator.send(':)')
  Got :)

چگونگی اجرای یک **Coroutine** همانند یک Generator‌ است ولی با این تفاوت که متد ``()send`` نیز برای ارسال مقدار به درون تابع در اختیار است.


با فراخوانی تابع Coroutine، بدنه اجرا نمی‌شود بلکه یک شی از نوع Generator‌ برگردانده می‌شود. متد ``()__next__`` (یا ``()next`` در پایتون 2x) اجرای برنامه را به نخستین ``yield`` می‌رساند، در این نقطه تابع در وضعیت تعلیق (Suspend) قرار می‌گیرد و آماده دریافت مقدار است. متد ``()send`` مقدار مورد نظر را به تابع ارسال می‌کند که این مقدار توسط عبارت ``(yield)`` در Coroutine دریافت می‌شود. پس از دریافت مقدار، اجرای Coroutine تا رسیدن به ``yield`` بعدی (در صورت وجود) یا انتهای بدنه تابع ادامه می‌یابد.

در بحث Coroutineها برای رهایی از فراخوانی متد ``()__next__`` می‌توان از Decorator‌ها استفاده کرد::


  >>> def coroutine(func):
  ...     def start(*args,**kwargs):
  ...         generator = func(*args,**kwargs)
  ...         generator.__next__()
  ...         return generator
  ...     return start
  ...   
  >>> 
  >>> @coroutine
  ... def receiver():
  ...     print("Ready to receive")
  ...     while True:
  ...         n = (yield)
  ...         print("Got %s" % n)
  ... 
  >>> 
  >>> receiver_generator = receiver()
  >>> receiver_generator.send('Hello World')  # Note : No initial .next()/.__next__() needed


یک Coroutine می‌تواند به دفعات نامحدود اجرا شود مگر اینکه اجرای آن توسط برنامه با فراخوانی متد ``()close`` یا به خودی خود با پایان خطوط اجرای تابع، پایان بپذیرد. 

چنانچه پس از پایان Coroutine، متد ``()send`` فراخوانی شود یک استثنا ``StopIteration`` رخ خواهد داد::

  >>> receiver_generator.close()
  >>> receiver_generator.send('value')
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  StopIteration


یک Coroutine می‌تواند همزمان با دریافت مقدار، خروجی نیز تولید و برگرداند::

  >>> def line_splitter(delimiter=None):
  ...     print("Ready to split")
  ...     result = None
  ...     while True:
  ...         line = (yield result)
  ...         result = line.split(delimiter)
  ... 
  >>> 
  >>> splitter = line_splitter(",")
  >>> splitter.__next__()
  Ready to split
  >>> splitter.send("A,B,C")
  ['A', 'B', 'C']
  >>> splitter.send("100,200,300")
  ['100', '200', '300']
  >>> 

**چه اتفاقی افتاد؟**







|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه



